
BaseArm7AT91:     format de fichier elf32-littlearm

Sections:
Idx Nom           Taille    VMA       LMA       Fich off  Algn
  0 .text         00002a8c  00100000  00100000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       0000001c  00102a8c  00102a8c  0000aa8c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         00000938  00200000  00102aa8  00010000  2**2
                  CONTENTS, ALLOC, LOAD, CODE
  3 .bss          000002d8  00200938  00200938  00010938  2**2
                  ALLOC
  4 .comment      0000029a  00000000  00000000  00010938  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000330  00000000  00000000  00010bd8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000776  00000000  00000000  00010f08  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00009433  00000000  00000000  0001167e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001ba3  00000000  00000000  0001aab1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000023b9  00000000  00000000  0001c654  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000b64  00000000  00000000  0001ea10  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001240  00000000  00000000  0001f574  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000023bd  00000000  00000000  000207b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macinfo 0008a939  00000000  00000000  00022b71  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000168  00000000  00000000  000ad4aa  2**0
                  CONTENTS, READONLY, DEBUGGING
Déassemblage de la section .text:

00100000 <main>:

/*** Main Program ***/

int main (void) 
{
  100000:	e52de004 	str	lr, [sp, #-4]!
	
	vFsysManager_Init();
  100004:	eb000004 	bl	10001c <vFsysManager_Init>
	vFdvManager_Init();
  100008:	eb00056b 	bl	1015bc <vFdvManager_Init>
	vFlibManager_Init();
  10000c:	eb00014f 	bl	100550 <vFlibManager_Init>
	vFappManager_Init();
  100010:	eb00058f 	bl	101654 <vFappManager_Init>
	
	while (1) 
	{                              /* Loop forever */
		vFappManager_Main();
  100014:	eb00058b 	bl	101648 <vFappManager_Main>
  100018:	eafffffd 	b	100014 <main+0x14>

0010001c <vFsysManager_Init>:
void vFsysManager_Init( void )
{
	// enable reset-button (mt)
	// AT91F_RSTSetMode( AT91C_BASE_RSTC , AT91C_RSTC_URSTEN );
	*AT91C_RSTC_RMR = ( 0xA5000000 | AT91C_RSTC_URSTEN );
  10001c:	e3e03000 	mvn	r3, #0	; 0x0
  100020:	e3a024a5 	mov	r2, #-1526726656	; 0xa5000000
  100024:	e2822001 	add	r2, r2, #1	; 0x1
  100028:	e50322f7 	str	r2, [r3, #-759]
	
	*AT91C_PMC_PCER = (1 << AT91C_ID_PIOA) |  /* Enable Clock for PIO    */
  10002c:	e3a02101 	mov	r2, #1073741824	; 0x40000000
  100030:	e2822044 	add	r2, r2, #68	; 0x44
  100034:	e50323ef 	str	r2, [r3, #-1007]
		(1 << AT91C_ID_IRQ0) |  /* Enable Clock for IRQ0   */
		(1 << AT91C_ID_US0);    /* Enable Clock for USART0 */
}
  100038:	e12fff1e 	bx	lr

0010003c <_close_r>:
    struct _reent *r, 
    int file)
{
	return 0;
}
  10003c:	e3a00000 	mov	r0, #0	; 0x0
  100040:	e12fff1e 	bx	lr

00100044 <_lseek_r>:


_off_t _lseek_r(
    struct _reent *r, 
    int file, 
    _off_t ptr, 
    int dir)
{
	return (_off_t)0;	/*  Always indicate we are at file beginning.  */
}
  100044:	e3a00000 	mov	r0, #0	; 0x0
  100048:	e12fff1e 	bx	lr

0010004c <_fstat_r>:


int _fstat_r(
    struct _reent *r, 
    int file, 
    struct stat *st)
{
	/*  Always set as character device.				*/
	st->st_mode = S_IFCHR;
  10004c:	e3a03a02 	mov	r3, #8192	; 0x2000
  100050:	e5823004 	str	r3, [r2, #4]
	/* assigned to strong type with implicit 	*/
	/* signed/unsigned conversion.  Required by 	*/
	/* newlib.					*/

	return 0;
}
  100054:	e3a00000 	mov	r0, #0	; 0x0
  100058:	e12fff1e 	bx	lr

0010005c <_sbrk_r>:


/*int isatty(int file); // avoid warning 

int isatty(int file)
{
	return 1;
}*/


#if 0
static void _exit (int n) {
label:  goto label; /* endless loop */
}
#endif 


/* "malloc clue function" from newlib-lpc/Keil-Demo/"generic" */

/**** Locally used variables. ****/
// mt: "cleaner": extern char* end;
extern char end[];              /*  end is set in the linker command 	*/
				/* file and is the end of statically 	*/
				/* allocated data (thus start of heap).	*/

static char *heap_ptr;		/* Points to current end of the heap.	*/

/************************** _sbrk_r *************************************
 * Support function. Adjusts end of heap to provide more memory to
 * memory allocator. Simple and dumb with no sanity checks.

 *  struct _reent *r -- re-entrancy structure, used by newlib to
 *                      support multiple threads of operation.
 *  ptrdiff_t nbytes -- number of bytes to add.
 *                      Returns pointer to start of new heap area.
 *
 *  Note:  This implementation is not thread safe (despite taking a
 *         _reent structure as a parameter).
 *         Since _s_r is not used in the current implementation, 
 *         the following messages must be suppressed.
 */
void * _sbrk_r(
    struct _reent *_s_r, 
    ptrdiff_t nbytes)
{
	char  *base;		/*  errno should be set to  ENOMEM on error  */

	if (!heap_ptr) {	/*  Initialize if first time through.  */
  10005c:	e59f2020 	ldr	r2, [pc, #32]	; 100084 <.text+0x84>
  100060:	e5923000 	ldr	r3, [r2]
  100064:	e3530000 	cmp	r3, #0	; 0x0
		heap_ptr = end;
  100068:	059f3018 	ldreq	r3, [pc, #24]	; 100088 <.text+0x88>
  10006c:	05823000 	streq	r3, [r2]
	}
	base = heap_ptr;	/*  Point to end of heap.  */
  100070:	e59f300c 	ldr	r3, [pc, #12]	; 100084 <.text+0x84>
  100074:	e5930000 	ldr	r0, [r3]
	heap_ptr += nbytes;	/*  Increase heap.  */
  100078:	e0802001 	add	r2, r0, r1
  10007c:	e5832000 	str	r2, [r3]
	
	return base;		/*  Return pointer to start of new heap area.  */
}
  100080:	e12fff1e 	bx	lr
  100084:	00200938 	eoreq	r0, r0, r8, lsr r9
  100088:	00200c10 	eoreq	r0, r0, r0, lsl ip

0010008c <_write_r>:
  10008c:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
  100090:	e2537000 	subs	r7, r3, #0	; 0x0
  100094:	0a00000b 	beq	1000c8 <_write_r+0x3c>
  100098:	e1a06002 	mov	r6, r2
  10009c:	e3a04000 	mov	r4, #0	; 0x0
  1000a0:	e1a05004 	mov	r5, r4
  1000a4:	e7d43006 	ldrb	r3, [r4, r6]
  1000a8:	e353000a 	cmp	r3, #10	; 0xa
  1000ac:	03a0000d 	moveq	r0, #13	; 0xd
  1000b0:	0b000290 	bleq	100af8 <uart0_putc>
  1000b4:	e7d50006 	ldrb	r0, [r5, r6]
  1000b8:	eb00028e 	bl	100af8 <uart0_putc>
  1000bc:	e2844001 	add	r4, r4, #1	; 0x1
  1000c0:	e1540007 	cmp	r4, r7
  1000c4:	1afffff5 	bne	1000a0 <_write_r+0x14>
  1000c8:	e1a00007 	mov	r0, r7
  1000cc:	e8bd80f0 	ldmia	sp!, {r4, r5, r6, r7, pc}

001000d0 <_read_r>:
  1000d0:	e92d45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
  1000d4:	e2538000 	subs	r8, r3, #0	; 0x0
  1000d8:	01a0a008 	moveq	sl, r8
  1000dc:	0a000015 	beq	100138 <_read_r+0x68>
  1000e0:	ea000002 	b	1000f0 <_read_r+0x20>
  1000e4:	e3a03000 	mov	r3, #0	; 0x0
  1000e8:	e5c73000 	strb	r3, [r7]
  1000ec:	ea000011 	b	100138 <_read_r+0x68>
  1000f0:	e1a06002 	mov	r6, r2
  1000f4:	e3a0a000 	mov	sl, #0	; 0x0
  1000f8:	e1a0400a 	mov	r4, sl
  1000fc:	e1a05004 	mov	r5, r4
  100100:	e0867004 	add	r7, r6, r4
  100104:	eb0002d3 	bl	100c58 <iFdvUart_kbhit>
  100108:	e3500000 	cmp	r0, #0	; 0x0
  10010c:	0afffffc 	beq	100104 <_read_r+0x34>
  100110:	eb0002e4 	bl	100ca8 <uart0_getc>
  100114:	e20000ff 	and	r0, r0, #255	; 0xff
  100118:	e350000d 	cmp	r0, #13	; 0xd
  10011c:	0afffff0 	beq	1000e4 <_read_r+0x14>
  100120:	e7c50006 	strb	r0, [r5, r6]
  100124:	eb000273 	bl	100af8 <uart0_putc>
  100128:	e284a001 	add	sl, r4, #1	; 0x1
  10012c:	e1a0400a 	mov	r4, sl
  100130:	e158000a 	cmp	r8, sl
  100134:	1afffff0 	bne	1000fc <_read_r+0x2c>
  100138:	e06a0008 	rsb	r0, sl, r8
  10013c:	e8bd85f0 	ldmia	sp!, {r4, r5, r6, r7, r8, sl, pc}

00100140 <cflibUart_SendReady>:

char cflibUart_SendReady( void )
{
	return 0;
}
  100140:	e3a00000 	mov	r0, #0	; 0x0
  100144:	e12fff1e 	bx	lr

00100148 <vFlibUart_SetRXByte>:

void vFlibUart_SetRXByte( unsigned char *pu8Byte)
{
	unsigned short uiIndex;
	
	uiIndex = tLibUartData.uiIndexIn+1;
  100148:	e59f3040 	ldr	r3, [pc, #64]	; 100190 <.text+0x190>
  10014c:	e593c080 	ldr	ip, [r3, #128]
  100150:	e28c3001 	add	r3, ip, #1	; 0x1
  100154:	e1a03803 	mov	r3, r3, lsl #16
	
	if( uiIndex >= kLIBUART_INPUT_BUFFER_SIZE )
  100158:	e353087f 	cmp	r3, #8323072	; 0x7f0000
  10015c:	91a01823 	movls	r1, r3, lsr #16
  100160:	83a01000 	movhi	r1, #0	; 0x0
		uiIndex = 0;
	if( tLibUartData.uiIndexOut != uiIndex )
  100164:	e59f2024 	ldr	r2, [pc, #36]	; 100190 <.text+0x190>
  100168:	e5923084 	ldr	r3, [r2, #132]
  10016c:	e1530001 	cmp	r3, r1
  100170:	012fff1e 	bxeq	lr
	{
		tLibUartData.tucInputBuffer[ tLibUartData.uiIndexIn ] = *pu8Byte;
  100174:	e5d03000 	ldrb	r3, [r0]
  100178:	e7c2300c 	strb	r3, [r2, ip]
		tLibUartData.uiIndexIn = uiIndex;
  10017c:	e5821080 	str	r1, [r2, #128]
		tLibUartData.uiByteCount++;
  100180:	e5923088 	ldr	r3, [r2, #136]
  100184:	e2833001 	add	r3, r3, #1	; 0x1
  100188:	e5823088 	str	r3, [r2, #136]
  10018c:	e12fff1e 	bx	lr
  100190:	0020093c 	eoreq	r0, r0, ip, lsr r9

00100194 <cFlibUart_SendBuff>:
  100194:	e92d4030 	stmdb	sp!, {r4, r5, lr}
  100198:	e1a04000 	mov	r4, r0
  10019c:	e1a05001 	mov	r5, r1
  1001a0:	eb000249 	bl	100acc <vFdvUart_WaitTXFree>
  1001a4:	e3540000 	cmp	r4, #0	; 0x0
  1001a8:	13550000 	cmpne	r5, #0	; 0x0
  1001ac:	0a00000e 	beq	1001ec <cFlibUart_SendBuff+0x58>
	unsigned int szBuffer,
	char *pNextBuffer,
	unsigned int szNextBuffer )
{
	return AT91F_PDC_SendFrame(
  1001b0:	e3a034ff 	mov	r3, #-16777216	; 0xff000000
  1001b4:	e283373f 	add	r3, r3, #16515072	; 0xfc0000
  1001b8:	e2832c01 	add	r2, r3, #256	; 0x100
  1001bc:	e592300c 	ldr	r3, [r2, #12]
  1001c0:	e3530000 	cmp	r3, #0	; 0x0
  1001c4:	1a000004 	bne	1001dc <cFlibUart_SendBuff+0x48>
  1001c8:	e5824008 	str	r4, [r2, #8]
  1001cc:	e582500c 	str	r5, [r2, #12]
  1001d0:	e5823018 	str	r3, [r2, #24]
  1001d4:	e582301c 	str	r3, [r2, #28]
  1001d8:	ea000003 	b	1001ec <cFlibUart_SendBuff+0x58>
  1001dc:	e592301c 	ldr	r3, [r2, #28]
  1001e0:	e3530000 	cmp	r3, #0	; 0x0
  1001e4:	05824018 	streq	r4, [r2, #24]
  1001e8:	0582501c 	streq	r5, [r2, #28]
  1001ec:	eb000236 	bl	100acc <vFdvUart_WaitTXFree>
  1001f0:	e3a00000 	mov	r0, #0	; 0x0
  1001f4:	e8bd8030 	ldmia	sp!, {r4, r5, pc}

001001f8 <vFlibUart_Init>:
  1001f8:	e52de004 	str	lr, [sp, #-4]!
  1001fc:	e59f2024 	ldr	r2, [pc, #36]	; 100228 <.text+0x228>
  100200:	e3a03000 	mov	r3, #0	; 0x0
  100204:	e5823080 	str	r3, [r2, #128]
  100208:	e5823084 	str	r3, [r2, #132]
  10020c:	e5823088 	str	r3, [r2, #136]
  100210:	e59f0014 	ldr	r0, [pc, #20]	; 10022c <.text+0x22c>
  100214:	eb000222 	bl	100aa4 <vFdvUart_SetRXCallback>
	AT91PS_USART pUSART, // \arg pointer to a USART controller
	unsigned int flag)   // \arg IT to be enabled
{
	//* Write to the IER register
	pUSART->US_IER = flag;
  100218:	e3a02001 	mov	r2, #1	; 0x1
  10021c:	e3e03bff 	mvn	r3, #261120	; 0x3fc00
  100220:	e50323f7 	str	r2, [r3, #-1015]
  100224:	e49df004 	ldr	pc, [sp], #4
  100228:	0020093c 	eoreq	r0, r0, ip, lsr r9
  10022c:	00100148 	andeqs	r0, r0, r8, asr #2

00100230 <cFlibUart_GetRXByte>:
	}

}

char cFlibUart_GetRXByte( unsigned char *pu8Byte)
{
  100230:	e1a0c000 	mov	ip, r0
	if(tLibUartData.uiByteCount)
  100234:	e59f3080 	ldr	r3, [pc, #128]	; 1002bc <.text+0x2bc>
  100238:	e5930088 	ldr	r0, [r3, #136]
  10023c:	e3500000 	cmp	r0, #0	; 0x0
  100240:	012fff1e 	bxeq	lr
	AT91PS_USART pUSART, // \arg pointer to a USART controller
	unsigned int flag)   // \arg IT to be disabled
{
	//* Write to the IER register
	pUSART->US_IDR = flag;
  100244:	e3a03001 	mov	r3, #1	; 0x1
  100248:	e3e02bff 	mvn	r2, #261120	; 0x3fc00
  10024c:	e50233f3 	str	r3, [r2, #-1011]
	{
		mDISABLE_UART_RX_IT();
		if( tLibUartData.uiIndexOut != tLibUartData.uiIndexIn )
  100250:	e59f1064 	ldr	r1, [pc, #100]	; 1002bc <.text+0x2bc>
  100254:	e5912084 	ldr	r2, [r1, #132]
  100258:	e5913080 	ldr	r3, [r1, #128]
  10025c:	e1520003 	cmp	r2, r3
  100260:	0a000010 	beq	1002a8 <cFlibUart_GetRXByte+0x78>
		{
			*pu8Byte = tLibUartData.tucInputBuffer[ tLibUartData.uiIndexOut ];
  100264:	e7d13002 	ldrb	r3, [r1, r2]
  100268:	e5cc3000 	strb	r3, [ip]
			tLibUartData.uiIndexOut++;
  10026c:	e5913084 	ldr	r3, [r1, #132]
  100270:	e2833001 	add	r3, r3, #1	; 0x1
  100274:	e5813084 	str	r3, [r1, #132]
			if( tLibUartData.uiIndexOut >= kLIBUART_INPUT_BUFFER_SIZE)
  100278:	e353007f 	cmp	r3, #127	; 0x7f
				tLibUartData.uiIndexOut = 0;
  10027c:	83a03000 	movhi	r3, #0	; 0x0
  100280:	85813084 	strhi	r3, [r1, #132]
			tLibUartData.uiByteCount--;
  100284:	e59f2030 	ldr	r2, [pc, #48]	; 1002bc <.text+0x2bc>
  100288:	e5923088 	ldr	r3, [r2, #136]
  10028c:	e2433001 	sub	r3, r3, #1	; 0x1
  100290:	e5823088 	str	r3, [r2, #136]
	AT91PS_USART pUSART, // \arg pointer to a USART controller
	unsigned int flag)   // \arg IT to be enabled
{
	//* Write to the IER register
	pUSART->US_IER = flag;
  100294:	e3a02001 	mov	r2, #1	; 0x1
  100298:	e3e03bff 	mvn	r3, #261120	; 0x3fc00
  10029c:	e50323f7 	str	r2, [r3, #-1015]
  1002a0:	e1a00002 	mov	r0, r2
  1002a4:	e12fff1e 	bx	lr
			mENABLE_UART_RX_IT();
			return 1;
		}
		mENABLE_UART_RX_IT();
	}
	return 0;
}
  1002a8:	e3a02001 	mov	r2, #1	; 0x1
  1002ac:	e3e03bff 	mvn	r3, #261120	; 0x3fc00
  1002b0:	e50323f7 	str	r2, [r3, #-1015]
  1002b4:	e3a00000 	mov	r0, #0	; 0x0
  1002b8:	e12fff1e 	bx	lr
  1002bc:	0020093c 	eoreq	r0, r0, ip, lsr r9

001002c0 <vFlibTimer_Tick>:
{
	unsigned char ucTimerCount;
	tPeriodicTimer *pTimer;
	
	for( ucTimerCount = 0 ; ucTimerCount < tlibTimerData.iHandlerCount ; ucTimerCount++ )
  1002c0:	e59f304c 	ldr	r3, [pc, #76]	; 100314 <.text+0x314>
  1002c4:	e593c000 	ldr	ip, [r3]
  1002c8:	e35c0000 	cmp	ip, #0	; 0x0
  1002cc:	d12fff1e 	bxle	lr
	{
		
		pTimer = tlibTimerData.ptTimerArray[ucTimerCount]; //newt timer
  1002d0:	e5930004 	ldr	r0, [r3, #4]
  1002d4:	e3a01000 	mov	r1, #0	; 0x0
  1002d8:	e7902101 	ldr	r2, [r0, r1, lsl #2]
		pTimer->uiCount--; //decrement the timer count
  1002dc:	e592300c 	ldr	r3, [r2, #12]
  1002e0:	e2433001 	sub	r3, r3, #1	; 0x1
  1002e4:	e582300c 	str	r3, [r2, #12]
		if(!pTimer->uiCount)
  1002e8:	e3530000 	cmp	r3, #0	; 0x0
		{	//new periodextern 
			pTimer->uiCount = pTimer->uiPeriod;
  1002ec:	05923004 	ldreq	r3, [r2, #4]
  1002f0:	0582300c 	streq	r3, [r2, #12]
			pTimer->uiPeriodCount++;
  1002f4:	05923008 	ldreq	r3, [r2, #8]
  1002f8:	02833001 	addeq	r3, r3, #1	; 0x1
  1002fc:	05823008 	streq	r3, [r2, #8]
  100300:	e2813001 	add	r3, r1, #1	; 0x1
  100304:	e20310ff 	and	r1, r3, #255	; 0xff
  100308:	e151000c 	cmp	r1, ip
  10030c:	bafffff1 	blt	1002d8 <vFlibTimer_Tick+0x18>
  100310:	e12fff1e 	bx	lr
  100314:	002009c8 	eoreq	r0, r0, r8, asr #19

00100318 <vFlibTimer_DeletPeriodicTimer>:
		}
	}
}

/// \brief Creat a new periodic Timer
/// \param uiPeiod period timer in ms
/// \return Pointer to the new timer
tPeriodicTimer *ptFlibTimer_NewPeriodicTimer( unsigned int uiPeriod )
{
	tPeriodicTimer *pNewTimer=NULL;
	
	if( tlibTimerData.iHandlerCount < LIBTIMER_MAX_TIMER_NUMBER )
	{
		//allocate memory for the new timer
		pNewTimer = (tPeriodicTimer*) malloc( sizeof( tPeriodicTimer)  );
		if( pNewTimer != NULL)
		{
			//add the new timer in the timer array
			if( realloc( tlibTimerData.ptTimerArray , (tlibTimerData.iHandlerCount+1)*sizeof(tPeriodicTimer*)) != NULL )
			{
				tlibTimerData.ptTimerArray[tlibTimerData.iHandlerCount] = pNewTimer;
				//update handler count
				kLIBTIMER_DISABLE_IT();
				tlibTimerData.iHandlerCount++;
				kLIBTIMER_ENABLE_IT();
				//init the new timer data
				pNewTimer->iHanler = tlibTimerData.iHandlerCount;
				pNewTimer->uiPeriod = uiPeriod;
				pNewTimer->uiPeriodCount= 0;
				pNewTimer->uiCount = uiPeriod;
			}
			else
			{
				free( pNewTimer );
				pNewTimer = NULL;
			}
		}
	}
	return pNewTimer;
}

void vFlibTimer_DeletPeriodicTimer( tPeriodicTimer *ptTimer)
{
  100318:	e52de004 	str	lr, [sp, #-4]!
	free( ptTimer );
  10031c:	eb000514 	bl	101774 <free>
	tlibTimerData.iHandlerCount--;
  100320:	e59f3018 	ldr	r3, [pc, #24]	; 100340 <.text+0x340>
  100324:	e5931000 	ldr	r1, [r3]
  100328:	e2411001 	sub	r1, r1, #1	; 0x1
  10032c:	e5831000 	str	r1, [r3]
	realloc( tlibTimerData.ptTimerArray , (tlibTimerData.iHandlerCount)*sizeof(tPeriodicTimer*));
  100330:	e5930004 	ldr	r0, [r3, #4]
  100334:	e1a01101 	mov	r1, r1, lsl #2
  100338:	eb0006f5 	bl	101f14 <realloc>
}
  10033c:	e49df004 	ldr	pc, [sp], #4
  100340:	002009c8 	eoreq	r0, r0, r8, asr #19

00100344 <vFlibTimer_Iinit>:
  100344:	e92d4010 	stmdb	sp!, {r4, lr}
  100348:	e59f4014 	ldr	r4, [pc, #20]	; 100364 <.text+0x364>
  10034c:	e3a03000 	mov	r3, #0	; 0x0
  100350:	e5843000 	str	r3, [r4]
  100354:	e3a00004 	mov	r0, #4	; 0x4
  100358:	eb00050a 	bl	101788 <malloc>
  10035c:	e5840004 	str	r0, [r4, #4]
  100360:	e8bd8010 	ldmia	sp!, {r4, pc}
  100364:	002009c8 	eoreq	r0, r0, r8, asr #19

00100368 <ptFlibTimer_NewPeriodicTimer>:
  100368:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
  10036c:	e1a06000 	mov	r6, r0
  100370:	e59f3090 	ldr	r3, [pc, #144]	; 100408 <.text+0x408>
  100374:	e5933000 	ldr	r3, [r3]
  100378:	e353000e 	cmp	r3, #14	; 0xe
  10037c:	c3a04000 	movgt	r4, #0	; 0x0
  100380:	ca00001e 	bgt	100400 <ptFlibTimer_NewPeriodicTimer+0x98>
  100384:	e3a00010 	mov	r0, #16	; 0x10
  100388:	eb0004fe 	bl	101788 <malloc>
  10038c:	e2504000 	subs	r4, r0, #0	; 0x0
  100390:	0a00001a 	beq	100400 <ptFlibTimer_NewPeriodicTimer+0x98>
  100394:	e59f506c 	ldr	r5, [pc, #108]	; 100408 <.text+0x408>
  100398:	e5951000 	ldr	r1, [r5]
  10039c:	e1a01101 	mov	r1, r1, lsl #2
  1003a0:	e5950004 	ldr	r0, [r5, #4]
  1003a4:	e2811004 	add	r1, r1, #4	; 0x4
  1003a8:	eb0006d9 	bl	101f14 <realloc>
  1003ac:	e3500000 	cmp	r0, #0	; 0x0
  1003b0:	0a00000f 	beq	1003f4 <ptFlibTimer_NewPeriodicTimer+0x8c>
  1003b4:	e895000a 	ldmia	r5, {r1, r3}
  1003b8:	e7834101 	str	r4, [r3, r1, lsl #2]
//*----------------------------------------------------------------------------
static __inline void AT91F_PITDisableInt(
        AT91PS_PITC pPITC)
{
	pPITC->PITC_PIMR &= ~AT91C_PITC_PITIEN;	 
  1003bc:	e3e02c02 	mvn	r2, #512	; 0x200
  1003c0:	e51230cf 	ldr	r3, [r2, #-207]
  1003c4:	e3c33402 	bic	r3, r3, #33554432	; 0x2000000
  1003c8:	e50230cf 	str	r3, [r2, #-207]
  1003cc:	e2811001 	add	r1, r1, #1	; 0x1
  1003d0:	e5851000 	str	r1, [r5]
//*----------------------------------------------------------------------------
static __inline void AT91F_PITEnableInt(
        AT91PS_PITC pPITC)
{
	pPITC->PITC_PIMR |= AT91C_PITC_PITIEN;	 
  1003d4:	e51230cf 	ldr	r3, [r2, #-207]
  1003d8:	e3833402 	orr	r3, r3, #33554432	; 0x2000000
  1003dc:	e50230cf 	str	r3, [r2, #-207]
  1003e0:	e8840042 	stmia	r4, {r1, r6}
  1003e4:	e3a03000 	mov	r3, #0	; 0x0
  1003e8:	e5843008 	str	r3, [r4, #8]
  1003ec:	e584600c 	str	r6, [r4, #12]
  1003f0:	ea000002 	b	100400 <ptFlibTimer_NewPeriodicTimer+0x98>
  1003f4:	e1a00004 	mov	r0, r4
  1003f8:	eb0004dd 	bl	101774 <free>
  1003fc:	e3a04000 	mov	r4, #0	; 0x0
  100400:	e1a00004 	mov	r0, r4
  100404:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
  100408:	002009c8 	eoreq	r0, r0, r8, asr #19

0010040c <vFlibTimer_GetCount>:

unsigned int  vFlibTimer_GetCount(tPeriodicTimer *ptTimer )
{
	unsigned int uiLocalCount=0;
	
	if( ptTimer->uiPeriodCount )
  10040c:	e5901008 	ldr	r1, [r0, #8]
  100410:	e3510000 	cmp	r1, #0	; 0x0
  100414:	0a000008 	beq	10043c <vFlibTimer_GetCount+0x30>
//*----------------------------------------------------------------------------
static __inline void AT91F_PITDisableInt(
        AT91PS_PITC pPITC)
{
	pPITC->PITC_PIMR &= ~AT91C_PITC_PITIEN;	 
  100418:	e3e02c02 	mvn	r2, #512	; 0x200
  10041c:	e51230cf 	ldr	r3, [r2, #-207]
  100420:	e3c33402 	bic	r3, r3, #33554432	; 0x2000000
  100424:	e50230cf 	str	r3, [r2, #-207]
	{
		kLIBTIMER_DISABLE_IT();
		uiLocalCount = ptTimer->uiPeriodCount;
		ptTimer->uiPeriodCount = 0;
  100428:	e3a03000 	mov	r3, #0	; 0x0
  10042c:	e5803008 	str	r3, [r0, #8]
//*----------------------------------------------------------------------------
static __inline void AT91F_PITEnableInt(
        AT91PS_PITC pPITC)
{
	pPITC->PITC_PIMR |= AT91C_PITC_PITIEN;	 
  100430:	e51230cf 	ldr	r3, [r2, #-207]
  100434:	e3833402 	orr	r3, r3, #33554432	; 0x2000000
  100438:	e50230cf 	str	r3, [r2, #-207]
		kLIBTIMER_ENABLE_IT();
	}
	
	return uiLocalCount;
}
  10043c:	e1a00001 	mov	r0, r1
  100440:	e12fff1e 	bx	lr

00100444 <TC_Configure>:
//------------------------------------------------------------------------------
void TC_Configure(AT91S_TC *pTc, unsigned int mode)
{
    // Disable TC clock
    pTc->TC_CCR = AT91C_TC_CLKDIS;
  100444:	e3a03002 	mov	r3, #2	; 0x2
  100448:	e5803000 	str	r3, [r0]

    // Disable interrupts
    pTc->TC_IDR = 0xFFFFFFFF;
  10044c:	e2433003 	sub	r3, r3, #3	; 0x3
  100450:	e5803028 	str	r3, [r0, #40]

    // Clear status register
    pTc->TC_SR;
  100454:	e5903020 	ldr	r3, [r0, #32]

    // Set mode
    pTc->TC_CMR = mode;
  100458:	e5801004 	str	r1, [r0, #4]
}
  10045c:	e12fff1e 	bx	lr

00100460 <TC_Start>:

//------------------------------------------------------------------------------
/// Starts the timer clock.
/// \param pTc  Pointer to an AT91S_TC instance.
//------------------------------------------------------------------------------
void TC_Start(AT91S_TC *pTc)
{
    pTc->TC_CCR = AT91C_TC_CLKEN | AT91C_TC_SWTRG;
  100460:	e3a03005 	mov	r3, #5	; 0x5
  100464:	e5803000 	str	r3, [r0]
}
  100468:	e12fff1e 	bx	lr

0010046c <TC_Stop>:

//------------------------------------------------------------------------------
/// Stops the timer clock.
/// \param pTc  Pointer to an AT91S_TC instance.
//------------------------------------------------------------------------------
void TC_Stop(AT91S_TC *pTc)
{
    pTc->TC_CCR = AT91C_TC_CLKDIS;
  10046c:	e3a03002 	mov	r3, #2	; 0x2
  100470:	e5803000 	str	r3, [r0]
}
  100474:	e12fff1e 	bx	lr

00100478 <TC_FindMckDivisor>:

//------------------------------------------------------------------------------
/// Finds the best MCK divisor given the timer frequency and MCK. The result
/// is guaranteed to satisfy the following equation:
///   (MCK / (DIV * 65536)) <= freq <= (MCK / DIV)
/// with DIV being the highest possible value.
/// Returns 1 if a divisor could be found; otherwise returns 0.
/// \param freq  Desired timer frequency.
/// \param mck  Master clock frequency.
/// \param div  Divisor value.
/// \param tcclks  TCCLKS field value for divisor.
//------------------------------------------------------------------------------
unsigned char TC_FindMckDivisor(
    unsigned int freq,
    unsigned int mck,
    unsigned int *div,
    unsigned int *tcclks)
{
  100478:	e92d47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  10047c:	e1a07000 	mov	r7, r0
  100480:	e1a06001 	mov	r6, r1
  100484:	e1a0a002 	mov	sl, r2
  100488:	e1a09003 	mov	r9, r3
  10048c:	e3a05000 	mov	r5, #0	; 0x0
  100490:	e59f40b4 	ldr	r4, [pc, #180]	; 10054c <.text+0x54c>
  100494:	ea000003 	b	1004a8 <TC_FindMckDivisor+0x30>
    const unsigned int divisors[5] = {2, 8, 32, 128,
#if defined(at91sam9260) || defined(at91sam9261) || defined(at91sam9263) \
    || defined(at91sam9xe) || defined(at91sam9rl64) || defined(at91cap9)
        BOARD_MCK / 32768};
#else
        1024};
#endif
    unsigned int index = 0;

    // Satisfy lower bound
    while (freq < ((mck / divisors[index]) / 65536)) {

        index++;
  100498:	e2855001 	add	r5, r5, #1	; 0x1
  10049c:	e2844004 	add	r4, r4, #4	; 0x4

        // If no divisor can be found, return 0
        if (index == 5) {
  1004a0:	e3550005 	cmp	r5, #5	; 0x5
  1004a4:	0a000023 	beq	100538 <TC_FindMckDivisor+0xc0>
  1004a8:	e1a00006 	mov	r0, r6
  1004ac:	e5941000 	ldr	r1, [r4]
  1004b0:	eb00046a 	bl	101660 <__aeabi_uidiv>
  1004b4:	e1570820 	cmp	r7, r0, lsr #16
  1004b8:	3afffff6 	bcc	100498 <TC_FindMckDivisor+0x20>
  1004bc:	ea00000a 	b	1004ec <TC_FindMckDivisor+0x74>

            return 0;
        }
    }

    // Try to maximise DIV while satisfying upper bound
    while (index < 4) {

        if (freq > (mck / divisors[index + 1])) {
  1004c0:	e2858001 	add	r8, r5, #1	; 0x1
  1004c4:	e1a00006 	mov	r0, r6
  1004c8:	e5941008 	ldr	r1, [r4, #8]
  1004cc:	eb000463 	bl	101660 <__aeabi_uidiv>
  1004d0:	e2844004 	add	r4, r4, #4	; 0x4
  1004d4:	e1570000 	cmp	r7, r0
  1004d8:	8a00000e 	bhi	100518 <TC_FindMckDivisor+0xa0>

            break;
  1004dc:	e1a05008 	mov	r5, r8
  1004e0:	e3550004 	cmp	r5, #4	; 0x4
  1004e4:	1afffff5 	bne	1004c0 <TC_FindMckDivisor+0x48>
  1004e8:	ea00000a 	b	100518 <TC_FindMckDivisor+0xa0>
  1004ec:	e3550003 	cmp	r5, #3	; 0x3
  1004f0:	8a000008 	bhi	100518 <TC_FindMckDivisor+0xa0>
  1004f4:	e2858001 	add	r8, r5, #1	; 0x1
  1004f8:	e59f404c 	ldr	r4, [pc, #76]	; 10054c <.text+0x54c>
  1004fc:	e1a00006 	mov	r0, r6
  100500:	e7941108 	ldr	r1, [r4, r8, lsl #2]
  100504:	eb000455 	bl	101660 <__aeabi_uidiv>
  100508:	e1570000 	cmp	r7, r0
  10050c:	90844105 	addls	r4, r4, r5, lsl #2
  100510:	91a05008 	movls	r5, r8
  100514:	9afffff1 	bls	1004e0 <TC_FindMckDivisor+0x68>
        }
        index++;
    }

    // Store results
    if (div) {
  100518:	e35a0000 	cmp	sl, #0	; 0x0

        *div = divisors[index];
  10051c:	159f3028 	ldrne	r3, [pc, #40]	; 10054c <.text+0x54c>
  100520:	17933105 	ldrne	r3, [r3, r5, lsl #2]
  100524:	158a3000 	strne	r3, [sl]
    }
    if (tcclks) {
  100528:	e3590000 	cmp	r9, #0	; 0x0
  10052c:	03a00001 	moveq	r0, #1	; 0x1
  100530:	08bd87f0 	ldmeqia	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  100534:	ea000001 	b	100540 <TC_FindMckDivisor+0xc8>
  100538:	e3a00000 	mov	r0, #0	; 0x0
  10053c:	e8bd87f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

        *tcclks = index;
  100540:	e5895000 	str	r5, [r9]
  100544:	e3a00001 	mov	r0, #1	; 0x1
    }

    return 1;
}
  100548:	e8bd87f0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  10054c:	00102a8c 	andeqs	r2, r0, ip, lsl #21

00100550 <vFlibManager_Init>:
#include "libTime/libTimer.h"
#include "libUart/libUart.h"

void vFlibManager_Init( void )
{
  100550:	e52de004 	str	lr, [sp, #-4]!
	vFlibTimer_Iinit();
  100554:	ebffff7a 	bl	100344 <vFlibTimer_Iinit>
	vFlibUart_Init();
  100558:	ebffff26 	bl	1001f8 <vFlibUart_Init>
}
  10055c:	e49df004 	ldr	pc, [sp], #4

00100560 <vFdvUart_init>:
#define USART_INTERRUPT_LEVEL		5
AT91S_USART * pUSART = AT91C_BASE_US0;      /* Global Pointer to USART0 */
void (*pvfRXCallback)(unsigned char*);

void vFdvUart_init (void) {                   /* Initialize Serial Interface */
  100560:	e1a0c00d 	mov	ip, sp
  100564:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  100568:	e24cb004 	sub	fp, ip, #4	; 0x4
  10056c:	e24dd004 	sub	sp, sp, #4	; 0x4
  /* mt: n.b: uart0 clock must be enabled to use it */

  *AT91C_PIOA_PDR = AT91C_PA5_RXD0 |        /* Enable RxD0 Pin */
  100570:	e3e03ebf 	mvn	r3, #3056	; 0xbf0
  100574:	e243300b 	sub	r3, r3, #11	; 0xb
  100578:	e3a02060 	mov	r2, #96	; 0x60
  10057c:	e5832000 	str	r2, [r3]
                    AT91C_PA6_TXD0;         /* Enalbe TxD0 Pin */

  	// Disable interrupts
  pUSART->US_IDR = (unsigned int) -1;
  100580:	e59f30c8 	ldr	r3, [pc, #200]	; 100650 <.text+0x650>
  100584:	e5932000 	ldr	r2, [r3]
  100588:	e3e03000 	mvn	r3, #0	; 0x0
  10058c:	e582300c 	str	r3, [r2, #12]

    // Timeguard disabled
  pUSART->US_TTGR = 0;
  100590:	e59f30b8 	ldr	r3, [pc, #184]	; 100650 <.text+0x650>
  100594:	e5932000 	ldr	r2, [r3]
  100598:	e3a03000 	mov	r3, #0	; 0x0
  10059c:	e5823028 	str	r3, [r2, #40]

  
  pUSART->US_CR = AT91C_US_RSTRX |          /* Reset Receiver      */
  1005a0:	e59f30a8 	ldr	r3, [pc, #168]	; 100650 <.text+0x650>
  1005a4:	e5932000 	ldr	r2, [r3]
  1005a8:	e3a030ac 	mov	r3, #172	; 0xac
  1005ac:	e5823000 	str	r3, [r2]
                  AT91C_US_RSTTX |          /* Reset Transmitter   */
                  AT91C_US_RXDIS |          /* Receiver Disable    */
                  AT91C_US_TXDIS;           /* Transmitter Disable */

  pUSART->US_MR = AT91C_US_USMODE_NORMAL |  /* Normal Mode */
  1005b0:	e59f3098 	ldr	r3, [pc, #152]	; 100650 <.text+0x650>
  1005b4:	e5932000 	ldr	r2, [r3]
  1005b8:	e3a03d23 	mov	r3, #2240	; 0x8c0
  1005bc:	e5823004 	str	r3, [r2, #4]
                  AT91C_US_CLKS_CLOCK    |  /* Clock = MCK */
                  AT91C_US_CHRL_8_BITS   |  /* 8-bit Data  */
                  AT91C_US_PAR_NONE      |  /* No Parity   */
                  AT91C_US_NBSTOP_1_BIT;    /* 1 Stop Bit  */

  pUSART->US_BRGR = BRD;                    /* Baud Rate Divisor */
  1005c0:	e59f3088 	ldr	r3, [pc, #136]	; 100650 <.text+0x650>
  1005c4:	e5932000 	ldr	r2, [r3]
  1005c8:	e3a0301a 	mov	r3, #26	; 0x1a
  1005cc:	e5823020 	str	r3, [r2, #32]

  //* Reset receiver and transmitter
      pUSART->US_CR = AT91C_US_RSTRX | AT91C_US_RSTTX ;
  1005d0:	e59f3078 	ldr	r3, [pc, #120]	; 100650 <.text+0x650>
  1005d4:	e5932000 	ldr	r2, [r3]
  1005d8:	e3a0300c 	mov	r3, #12	; 0xc
  1005dc:	e5823000 	str	r3, [r2]
  
      pUSART->US_CR = AT91C_US_RXEN  |          /* Receiver Enable     */
  1005e0:	e59f3068 	ldr	r3, [pc, #104]	; 100650 <.text+0x650>
  1005e4:	e5932000 	ldr	r2, [r3]
  1005e8:	e3a03050 	mov	r3, #80	; 0x50
  1005ec:	e5823000 	str	r3, [r2]
                  AT91C_US_TXEN;            /* Transmitter Enable  */
  //* Enable USART IT AT91C_US_ENDRX
  	AT91F_US_EnableIt(AT91C_BASE_US0, AT91C_US_RXRDY);
  1005f0:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
  1005f4:	e1a006c0 	mov	r0, r0, asr #13
  1005f8:	e3a01001 	mov	r1, #1	; 0x1
  1005fc:	eb000016 	bl	10065c <AT91F_US_EnableIt>
  //* open Usart 0 interrupt
  	AT91F_AIC_ConfigureIt ( AT91C_BASE_AIC, AT91C_ID_US0, USART_INTERRUPT_LEVEL,AT91C_AIC_SRCTYPE_HIGH_LEVEL, (void (*) ())SerialIsr_Wrapper); 
  100600:	e59f304c 	ldr	r3, [pc, #76]	; 100654 <.text+0x654>
  100604:	e58d3000 	str	r3, [sp]
  100608:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
  10060c:	e1a009c0 	mov	r0, r0, asr #19
  100610:	e3a01006 	mov	r1, #6	; 0x6
  100614:	e3a02005 	mov	r2, #5	; 0x5
  100618:	e3a03040 	mov	r3, #64	; 0x40
  10061c:	eb000019 	bl	100688 <AT91F_AIC_ConfigureIt>
  	AT91F_AIC_EnableIt (AT91C_BASE_AIC, AT91C_ID_US0);
  100620:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
  100624:	e1a009c0 	mov	r0, r0, asr #19
  100628:	e3a01006 	mov	r1, #6	; 0x6
  10062c:	eb000042 	bl	10073c <AT91F_AIC_EnableIt>

  	pvfRXCallback=0;
  100630:	e59f2020 	ldr	r2, [pc, #32]	; 100658 <.text+0x658>
  100634:	e3a03000 	mov	r3, #0	; 0x0
  100638:	e5823000 	str	r3, [r2]
  	AT91F_PDC_Open(AT91C_BASE_PDC_US0);
  10063c:	e3a004ff 	mov	r0, #-16777216	; 0xff000000
  100640:	e280073f 	add	r0, r0, #16515072	; 0xfc0000
  100644:	e2800c01 	add	r0, r0, #256	; 0x100
  100648:	eb000049 	bl	100774 <AT91F_PDC_Open>
  	//AT91F_PDC_Close(AT91C_BASE_PDC_US0);
  	/*AT91F_PDC_DisableTx(AT91C_BASE_PDC_US0);
  	AT91F_PDC_SetNextTx(AT91C_BASE_PDC_US0, (char *) 0, 0);
  	AT91F_PDC_SetTx(AT91C_BASE_PDC_US0, (char *) 0, 0);
  	AT91F_PDC_EnableTx(AT91C_BASE_PDC_US0);*/
}
  10064c:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
  100650:	00200004 	eoreq	r0, r0, r4
  100654:	00100a84 	andeqs	r0, r0, r4, lsl #21
  100658:	00200a08 	eoreq	r0, r0, r8, lsl #20

0010065c <AT91F_US_EnableIt>:
//*----------------------------------------------------------------------------
static __inline void AT91F_US_EnableIt (
	AT91PS_USART pUSART, // \arg pointer to a USART controller
	unsigned int flag)   // \arg IT to be enabled
{
  10065c:	e1a0c00d 	mov	ip, sp
  100660:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  100664:	e24cb004 	sub	fp, ip, #4	; 0x4
  100668:	e24dd008 	sub	sp, sp, #8	; 0x8
  10066c:	e50b0010 	str	r0, [fp, #-16]
  100670:	e50b1014 	str	r1, [fp, #-20]
	//* Write to the IER register
	pUSART->US_IER = flag;
  100674:	e51b2010 	ldr	r2, [fp, #-16]
  100678:	e51b3014 	ldr	r3, [fp, #-20]
  10067c:	e5823008 	str	r3, [r2, #8]
}
  100680:	e24bd00c 	sub	sp, fp, #12	; 0xc
  100684:	e89da800 	ldmia	sp, {fp, sp, pc}

00100688 <AT91F_AIC_ConfigureIt>:
  100688:	e1a0c00d 	mov	ip, sp
  10068c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  100690:	e24cb004 	sub	fp, ip, #4	; 0x4
  100694:	e24dd018 	sub	sp, sp, #24	; 0x18
  100698:	e50b0018 	str	r0, [fp, #-24]
  10069c:	e50b101c 	str	r1, [fp, #-28]
  1006a0:	e50b2020 	str	r2, [fp, #-32]
  1006a4:	e50b3024 	str	r3, [fp, #-36]
  1006a8:	e51b301c 	ldr	r3, [fp, #-28]
  1006ac:	e51b2018 	ldr	r2, [fp, #-24]
  1006b0:	e3a01080 	mov	r1, #128	; 0x80
  1006b4:	e1a03103 	mov	r3, r3, lsl #2
  1006b8:	e0833002 	add	r3, r3, r2
  1006bc:	e0833001 	add	r3, r3, r1
  1006c0:	e5933000 	ldr	r3, [r3]
  1006c4:	e50b3014 	str	r3, [fp, #-20]
  1006c8:	e51b201c 	ldr	r2, [fp, #-28]
  1006cc:	e3a03001 	mov	r3, #1	; 0x1
  1006d0:	e1a03213 	mov	r3, r3, lsl r2
  1006d4:	e50b3010 	str	r3, [fp, #-16]
  1006d8:	e51b2018 	ldr	r2, [fp, #-24]
  1006dc:	e51b3010 	ldr	r3, [fp, #-16]
  1006e0:	e5823124 	str	r3, [r2, #292]
  1006e4:	e51b001c 	ldr	r0, [fp, #-28]
  1006e8:	e59b3004 	ldr	r3, [fp, #4]
  1006ec:	e1a0c003 	mov	ip, r3
  1006f0:	e51b2018 	ldr	r2, [fp, #-24]
  1006f4:	e3a01080 	mov	r1, #128	; 0x80
  1006f8:	e1a03100 	mov	r3, r0, lsl #2
  1006fc:	e0833002 	add	r3, r3, r2
  100700:	e0833001 	add	r3, r3, r1
  100704:	e583c000 	str	ip, [r3]
  100708:	e51b101c 	ldr	r1, [fp, #-28]
  10070c:	e51b2024 	ldr	r2, [fp, #-36]
  100710:	e51b3020 	ldr	r3, [fp, #-32]
  100714:	e1822003 	orr	r2, r2, r3
  100718:	e51b3018 	ldr	r3, [fp, #-24]
  10071c:	e7832101 	str	r2, [r3, r1, lsl #2]
  100720:	e51b2018 	ldr	r2, [fp, #-24]
  100724:	e51b3010 	ldr	r3, [fp, #-16]
  100728:	e5823128 	str	r3, [r2, #296]
  10072c:	e51b3014 	ldr	r3, [fp, #-20]
  100730:	e1a00003 	mov	r0, r3
  100734:	e24bd00c 	sub	sp, fp, #12	; 0xc
  100738:	e89da800 	ldmia	sp, {fp, sp, pc}

0010073c <AT91F_AIC_EnableIt>:
  10073c:	e1a0c00d 	mov	ip, sp
  100740:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  100744:	e24cb004 	sub	fp, ip, #4	; 0x4
  100748:	e24dd008 	sub	sp, sp, #8	; 0x8
  10074c:	e50b0010 	str	r0, [fp, #-16]
  100750:	e50b1014 	str	r1, [fp, #-20]
  100754:	e51b2014 	ldr	r2, [fp, #-20]
  100758:	e3a03001 	mov	r3, #1	; 0x1
  10075c:	e1a03213 	mov	r3, r3, lsl r2
  100760:	e1a02003 	mov	r2, r3
  100764:	e51b3010 	ldr	r3, [fp, #-16]
  100768:	e5832120 	str	r2, [r3, #288]
  10076c:	e24bd00c 	sub	sp, fp, #12	; 0xc
  100770:	e89da800 	ldmia	sp, {fp, sp, pc}

00100774 <AT91F_PDC_Open>:
  100774:	e1a0c00d 	mov	ip, sp
  100778:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  10077c:	e24cb004 	sub	fp, ip, #4	; 0x4
  100780:	e24dd004 	sub	sp, sp, #4	; 0x4
  100784:	e50b0010 	str	r0, [fp, #-16]
  100788:	e51b0010 	ldr	r0, [fp, #-16]
  10078c:	eb000016 	bl	1007ec <AT91F_PDC_DisableRx>
  100790:	e51b0010 	ldr	r0, [fp, #-16]
  100794:	eb00001d 	bl	100810 <AT91F_PDC_DisableTx>
  100798:	e51b0010 	ldr	r0, [fp, #-16]
  10079c:	e3a01000 	mov	r1, #0	; 0x0
  1007a0:	e3a02000 	mov	r2, #0	; 0x0
  1007a4:	eb000022 	bl	100834 <AT91F_PDC_SetNextTx>
  1007a8:	e51b0010 	ldr	r0, [fp, #-16]
  1007ac:	e3a01000 	mov	r1, #0	; 0x0
  1007b0:	e3a02000 	mov	r2, #0	; 0x0
  1007b4:	eb00002e 	bl	100874 <AT91F_PDC_SetNextRx>
  1007b8:	e51b0010 	ldr	r0, [fp, #-16]
  1007bc:	e3a01000 	mov	r1, #0	; 0x0
  1007c0:	e3a02000 	mov	r2, #0	; 0x0
  1007c4:	eb00003a 	bl	1008b4 <AT91F_PDC_SetTx>
  1007c8:	e51b0010 	ldr	r0, [fp, #-16]
  1007cc:	e3a01000 	mov	r1, #0	; 0x0
  1007d0:	e3a02000 	mov	r2, #0	; 0x0
  1007d4:	eb000046 	bl	1008f4 <AT91F_PDC_SetRx>
  1007d8:	e51b0010 	ldr	r0, [fp, #-16]
  1007dc:	eb000054 	bl	100934 <AT91F_PDC_EnableRx>
  1007e0:	e51b0010 	ldr	r0, [fp, #-16]
  1007e4:	eb00005b 	bl	100958 <AT91F_PDC_EnableTx>
  1007e8:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

001007ec <AT91F_PDC_DisableRx>:
  1007ec:	e1a0c00d 	mov	ip, sp
  1007f0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  1007f4:	e24cb004 	sub	fp, ip, #4	; 0x4
  1007f8:	e24dd004 	sub	sp, sp, #4	; 0x4
  1007fc:	e50b0010 	str	r0, [fp, #-16]
  100800:	e51b2010 	ldr	r2, [fp, #-16]
  100804:	e3a03002 	mov	r3, #2	; 0x2
  100808:	e5823020 	str	r3, [r2, #32]
  10080c:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

00100810 <AT91F_PDC_DisableTx>:
  100810:	e1a0c00d 	mov	ip, sp
  100814:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  100818:	e24cb004 	sub	fp, ip, #4	; 0x4
  10081c:	e24dd004 	sub	sp, sp, #4	; 0x4
  100820:	e50b0010 	str	r0, [fp, #-16]
  100824:	e51b2010 	ldr	r2, [fp, #-16]
  100828:	e3a03c02 	mov	r3, #512	; 0x200
  10082c:	e5823020 	str	r3, [r2, #32]
  100830:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

00100834 <AT91F_PDC_SetNextTx>:
  100834:	e1a0c00d 	mov	ip, sp
  100838:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  10083c:	e24cb004 	sub	fp, ip, #4	; 0x4
  100840:	e24dd00c 	sub	sp, sp, #12	; 0xc
  100844:	e50b0010 	str	r0, [fp, #-16]
  100848:	e50b1014 	str	r1, [fp, #-20]
  10084c:	e50b2018 	str	r2, [fp, #-24]
  100850:	e51b3014 	ldr	r3, [fp, #-20]
  100854:	e1a02003 	mov	r2, r3
  100858:	e51b3010 	ldr	r3, [fp, #-16]
  10085c:	e5832018 	str	r2, [r3, #24]
  100860:	e51b2010 	ldr	r2, [fp, #-16]
  100864:	e51b3018 	ldr	r3, [fp, #-24]
  100868:	e582301c 	str	r3, [r2, #28]
  10086c:	e24bd00c 	sub	sp, fp, #12	; 0xc
  100870:	e89da800 	ldmia	sp, {fp, sp, pc}

00100874 <AT91F_PDC_SetNextRx>:
  100874:	e1a0c00d 	mov	ip, sp
  100878:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  10087c:	e24cb004 	sub	fp, ip, #4	; 0x4
  100880:	e24dd00c 	sub	sp, sp, #12	; 0xc
  100884:	e50b0010 	str	r0, [fp, #-16]
  100888:	e50b1014 	str	r1, [fp, #-20]
  10088c:	e50b2018 	str	r2, [fp, #-24]
  100890:	e51b3014 	ldr	r3, [fp, #-20]
  100894:	e1a02003 	mov	r2, r3
  100898:	e51b3010 	ldr	r3, [fp, #-16]
  10089c:	e5832010 	str	r2, [r3, #16]
  1008a0:	e51b2010 	ldr	r2, [fp, #-16]
  1008a4:	e51b3018 	ldr	r3, [fp, #-24]
  1008a8:	e5823014 	str	r3, [r2, #20]
  1008ac:	e24bd00c 	sub	sp, fp, #12	; 0xc
  1008b0:	e89da800 	ldmia	sp, {fp, sp, pc}

001008b4 <AT91F_PDC_SetTx>:
  1008b4:	e1a0c00d 	mov	ip, sp
  1008b8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  1008bc:	e24cb004 	sub	fp, ip, #4	; 0x4
  1008c0:	e24dd00c 	sub	sp, sp, #12	; 0xc
  1008c4:	e50b0010 	str	r0, [fp, #-16]
  1008c8:	e50b1014 	str	r1, [fp, #-20]
  1008cc:	e50b2018 	str	r2, [fp, #-24]
  1008d0:	e51b3014 	ldr	r3, [fp, #-20]
  1008d4:	e1a02003 	mov	r2, r3
  1008d8:	e51b3010 	ldr	r3, [fp, #-16]
  1008dc:	e5832008 	str	r2, [r3, #8]
  1008e0:	e51b2010 	ldr	r2, [fp, #-16]
  1008e4:	e51b3018 	ldr	r3, [fp, #-24]
  1008e8:	e582300c 	str	r3, [r2, #12]
  1008ec:	e24bd00c 	sub	sp, fp, #12	; 0xc
  1008f0:	e89da800 	ldmia	sp, {fp, sp, pc}

001008f4 <AT91F_PDC_SetRx>:
  1008f4:	e1a0c00d 	mov	ip, sp
  1008f8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  1008fc:	e24cb004 	sub	fp, ip, #4	; 0x4
  100900:	e24dd00c 	sub	sp, sp, #12	; 0xc
  100904:	e50b0010 	str	r0, [fp, #-16]
  100908:	e50b1014 	str	r1, [fp, #-20]
  10090c:	e50b2018 	str	r2, [fp, #-24]
  100910:	e51b3014 	ldr	r3, [fp, #-20]
  100914:	e1a02003 	mov	r2, r3
  100918:	e51b3010 	ldr	r3, [fp, #-16]
  10091c:	e5832000 	str	r2, [r3]
  100920:	e51b2010 	ldr	r2, [fp, #-16]
  100924:	e51b3018 	ldr	r3, [fp, #-24]
  100928:	e5823004 	str	r3, [r2, #4]
  10092c:	e24bd00c 	sub	sp, fp, #12	; 0xc
  100930:	e89da800 	ldmia	sp, {fp, sp, pc}

00100934 <AT91F_PDC_EnableRx>:
  100934:	e1a0c00d 	mov	ip, sp
  100938:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  10093c:	e24cb004 	sub	fp, ip, #4	; 0x4
  100940:	e24dd004 	sub	sp, sp, #4	; 0x4
  100944:	e50b0010 	str	r0, [fp, #-16]
  100948:	e51b2010 	ldr	r2, [fp, #-16]
  10094c:	e3a03001 	mov	r3, #1	; 0x1
  100950:	e5823020 	str	r3, [r2, #32]
  100954:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

00100958 <AT91F_PDC_EnableTx>:
  100958:	e1a0c00d 	mov	ip, sp
  10095c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  100960:	e24cb004 	sub	fp, ip, #4	; 0x4
  100964:	e24dd004 	sub	sp, sp, #4	; 0x4
  100968:	e50b0010 	str	r0, [fp, #-16]
  10096c:	e51b2010 	ldr	r2, [fp, #-16]
  100970:	e3a03c01 	mov	r3, #256	; 0x100
  100974:	e5823020 	str	r3, [r2, #32]
  100978:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

0010097c <usart_c_irq_handler>:

void usart_c_irq_handler( void )
{
  10097c:	e1a0c00d 	mov	ip, sp
  100980:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  100984:	e24cb004 	sub	fp, ip, #4	; 0x4
  100988:	e24dd008 	sub	sp, sp, #8	; 0x8
	//volatile unsigned int status;
	volatile unsigned char ucByteIn;
	volatile unsigned int uiStatus;
	
	uiStatus = AT91C_BASE_US0->US_CSR;
  10098c:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
  100990:	e1a036c3 	mov	r3, r3, asr #13
  100994:	e5933014 	ldr	r3, [r3, #20]
  100998:	e50b3014 	str	r3, [fp, #-20]
	uiStatus &= AT91C_BASE_US0->US_IMR;
  10099c:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
  1009a0:	e1a036c3 	mov	r3, r3, asr #13
  1009a4:	e5932010 	ldr	r2, [r3, #16]
  1009a8:	e51b3014 	ldr	r3, [fp, #-20]
  1009ac:	e0023003 	and	r3, r2, r3
  1009b0:	e50b3014 	str	r3, [fp, #-20]
	//* get Usart status register
	//if ( AT91F_US_RxReady(AT91C_BASE_US0)&AT91C_US_RXRDY )
	 if ( uiStatus&AT91C_US_RXRDY )
  1009b4:	e51b3014 	ldr	r3, [fp, #-20]
  1009b8:	e2033001 	and	r3, r3, #1	; 0x1
  1009bc:	e20330ff 	and	r3, r3, #255	; 0xff
  1009c0:	e3530000 	cmp	r3, #0	; 0x0
  1009c4:	0a00000f 	beq	100a08 <usart_c_irq_handler+0x8c>
	{
		ucByteIn = AT91F_US_GetChar( AT91C_BASE_US0 );
  1009c8:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
  1009cc:	e1a006c0 	mov	r0, r0, asr #13
  1009d0:	eb000016 	bl	100a30 <AT91F_US_GetChar>
  1009d4:	e1a03000 	mov	r3, r0
  1009d8:	e20330ff 	and	r3, r3, #255	; 0xff
  1009dc:	e54b300d 	strb	r3, [fp, #-13]
		if( pvfRXCallback )
  1009e0:	e59f3044 	ldr	r3, [pc, #68]	; 100a2c <.text+0xa2c>
  1009e4:	e5933000 	ldr	r3, [r3]
  1009e8:	e3530000 	cmp	r3, #0	; 0x0
  1009ec:	0a000005 	beq	100a08 <usart_c_irq_handler+0x8c>
			pvfRXCallback((unsigned char*)&ucByteIn);
  1009f0:	e59f3034 	ldr	r3, [pc, #52]	; 100a2c <.text+0xa2c>
  1009f4:	e5932000 	ldr	r2, [r3]
  1009f8:	e24b300d 	sub	r3, fp, #13	; 0xd
  1009fc:	e1a00003 	mov	r0, r3
  100a00:	e1a0e00f 	mov	lr, pc
  100a04:	e12fff12 	bx	r2
	}
	
	//* Reset the satus bit
	 AT91C_BASE_US0->US_CR = AT91C_US_RSTSTA;
  100a08:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
  100a0c:	e1a036c3 	mov	r3, r3, asr #13
  100a10:	e3a02c01 	mov	r2, #256	; 0x100
  100a14:	e5832000 	str	r2, [r3]
	AT91F_AIC_AcknowledgeIt(AT91C_BASE_AIC);
  100a18:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
  100a1c:	e1a009c0 	mov	r0, r0, asr #19
  100a20:	eb00000d 	bl	100a5c <AT91F_AIC_AcknowledgeIt>
}
  100a24:	e24bd00c 	sub	sp, fp, #12	; 0xc
  100a28:	e89da800 	ldmia	sp, {fp, sp, pc}
  100a2c:	00200a08 	eoreq	r0, r0, r8, lsl #20

00100a30 <AT91F_US_GetChar>:
//* \brief Receive a character,does not check if a character is available
//*----------------------------------------------------------------------------
static __inline int AT91F_US_GetChar (
	const AT91PS_USART pUSART)
{
  100a30:	e1a0c00d 	mov	ip, sp
  100a34:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  100a38:	e24cb004 	sub	fp, ip, #4	; 0x4
  100a3c:	e24dd004 	sub	sp, sp, #4	; 0x4
  100a40:	e50b0010 	str	r0, [fp, #-16]
    return((pUSART->US_RHR) & 0x1FF);
  100a44:	e51b3010 	ldr	r3, [fp, #-16]
  100a48:	e5933018 	ldr	r3, [r3, #24]
  100a4c:	e1a03b83 	mov	r3, r3, lsl #23
  100a50:	e1a03ba3 	mov	r3, r3, lsr #23
}
  100a54:	e1a00003 	mov	r0, r3
  100a58:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

00100a5c <AT91F_AIC_AcknowledgeIt>:
  100a5c:	e1a0c00d 	mov	ip, sp
  100a60:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  100a64:	e24cb004 	sub	fp, ip, #4	; 0x4
  100a68:	e24dd004 	sub	sp, sp, #4	; 0x4
  100a6c:	e50b0010 	str	r0, [fp, #-16]
  100a70:	e51b3010 	ldr	r3, [fp, #-16]
  100a74:	e5932130 	ldr	r2, [r3, #304]
  100a78:	e51b3010 	ldr	r3, [fp, #-16]
  100a7c:	e5832130 	str	r2, [r3, #304]
  100a80:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

00100a84 <SerialIsr_Wrapper>:

void NACKEDFUNC SerialIsr_Wrapper( void )
{
	/* Save the context of the interrupted task. */
	ISR_ENTRY();
  100a84:	e24ee004 	sub	lr, lr, #4	; 0x4
  100a88:	e92d5fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
  100a8c:	e14f1000 	mrs	r1, SPSR
  100a90:	e92d0002 	stmdb	sp!, {r1}

	/* Call the handler to do the work.  This must be a separate
	function to ensure the stack frame is set up correctly. */
	usart_c_irq_handler();
  100a94:	ebffffb8 	bl	10097c <usart_c_irq_handler>

	/* Restore the context of whichever task will execute next. */
	ISR_EXIT();
  100a98:	e8bd0002 	ldmia	sp!, {r1}
  100a9c:	e161f001 	msr	SPSR_c, r1
  100aa0:	e8fd9fff 	ldmia	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, pc}^

00100aa4 <vFdvUart_SetRXCallback>:
}

void vFdvUart_SetRXCallback( void (*callback)(unsigned char*))
{
  100aa4:	e1a0c00d 	mov	ip, sp
  100aa8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  100aac:	e24cb004 	sub	fp, ip, #4	; 0x4
  100ab0:	e24dd004 	sub	sp, sp, #4	; 0x4
  100ab4:	e50b0010 	str	r0, [fp, #-16]
	pvfRXCallback = callback;
  100ab8:	e59f2008 	ldr	r2, [pc, #8]	; 100ac8 <.text+0xac8>
  100abc:	e51b3010 	ldr	r3, [fp, #-16]
  100ac0:	e5823000 	str	r3, [r2]

}
  100ac4:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
  100ac8:	00200a08 	eoreq	r0, r0, r8, lsl #20

00100acc <vFdvUart_WaitTXFree>:

void vFdvUart_WaitTXFree(void)
{
  100acc:	e1a0c00d 	mov	ip, sp
  100ad0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  100ad4:	e24cb004 	sub	fp, ip, #4	; 0x4
	while (!(pUSART->US_CSR & AT91C_US_TXRDY));   /* Wait for Empty Tx Buffer */
  100ad8:	e59f3014 	ldr	r3, [pc, #20]	; 100af4 <.text+0xaf4>
  100adc:	e5933000 	ldr	r3, [r3]
  100ae0:	e5933014 	ldr	r3, [r3, #20]
  100ae4:	e2033002 	and	r3, r3, #2	; 0x2
  100ae8:	e3530000 	cmp	r3, #0	; 0x0
  100aec:	0afffff9 	beq	100ad8 <vFdvUart_WaitTXFree+0xc>
}
  100af0:	e89da800 	ldmia	sp, {fp, sp, pc}
  100af4:	00200004 	eoreq	r0, r0, r4

00100af8 <uart0_putc>:

int uart0_putc(int ch) 
{
  100af8:	e1a0c00d 	mov	ip, sp
  100afc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  100b00:	e24cb004 	sub	fp, ip, #4	; 0x4
  100b04:	e24dd004 	sub	sp, sp, #4	; 0x4
  100b08:	e50b0010 	str	r0, [fp, #-16]
	while (!(pUSART->US_CSR & AT91C_US_TXRDY));   /* Wait for Empty Tx Buffer */
  100b0c:	e59f302c 	ldr	r3, [pc, #44]	; 100b40 <.text+0xb40>
  100b10:	e5933000 	ldr	r3, [r3]
  100b14:	e5933014 	ldr	r3, [r3, #20]
  100b18:	e2033002 	and	r3, r3, #2	; 0x2
  100b1c:	e3530000 	cmp	r3, #0	; 0x0
  100b20:	0afffff9 	beq	100b0c <uart0_putc+0x14>
	return (pUSART->US_THR = ch);                 /* Transmit Character */
  100b24:	e59f3014 	ldr	r3, [pc, #20]	; 100b40 <.text+0xb40>
  100b28:	e5932000 	ldr	r2, [r3]
  100b2c:	e51b3010 	ldr	r3, [fp, #-16]
  100b30:	e582301c 	str	r3, [r2, #28]
  100b34:	e592301c 	ldr	r3, [r2, #28]
}	
  100b38:	e1a00003 	mov	r0, r3
  100b3c:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
  100b40:	00200004 	eoreq	r0, r0, r4

00100b44 <uart0_putchar>:

int uart0_putchar (int ch) {                      /* Write Character to Serial Port */
  100b44:	e1a0c00d 	mov	ip, sp
  100b48:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  100b4c:	e24cb004 	sub	fp, ip, #4	; 0x4
  100b50:	e24dd004 	sub	sp, sp, #4	; 0x4
  100b54:	e50b0010 	str	r0, [fp, #-16]

  if (ch == '\n')  {                            /* Check for LF */
  100b58:	e51b3010 	ldr	r3, [fp, #-16]
  100b5c:	e353000a 	cmp	r3, #10	; 0xa
  100b60:	1a000001 	bne	100b6c <uart0_putchar+0x28>
    uart0_putc( '\r' );                         /* Output CR */
  100b64:	e3a0000d 	mov	r0, #13	; 0xd
  100b68:	ebffffe2 	bl	100af8 <uart0_putc>
  }
  return uart0_putc( ch );                     /* Transmit Character */
  100b6c:	e51b0010 	ldr	r0, [fp, #-16]
  100b70:	ebffffe0 	bl	100af8 <uart0_putc>
  100b74:	e1a03000 	mov	r3, r0
}
  100b78:	e1a00003 	mov	r0, r3
  100b7c:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

00100b80 <uart0_puts>:

int uart0_puts ( char* s )
{
  100b80:	e1a0c00d 	mov	ip, sp
  100b84:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  100b88:	e24cb004 	sub	fp, ip, #4	; 0x4
  100b8c:	e24dd008 	sub	sp, sp, #8	; 0x8
  100b90:	e50b0014 	str	r0, [fp, #-20]
	int i = 0;
  100b94:	e3a03000 	mov	r3, #0	; 0x0
  100b98:	e50b3010 	str	r3, [fp, #-16]
	while ( *s ) {
  100b9c:	ea00000a 	b	100bcc <uart0_puts+0x4c>
		uart0_putc( *s++ );
  100ba0:	e51b3014 	ldr	r3, [fp, #-20]
  100ba4:	e5d33000 	ldrb	r3, [r3]
  100ba8:	e1a02003 	mov	r2, r3
  100bac:	e51b3014 	ldr	r3, [fp, #-20]
  100bb0:	e2833001 	add	r3, r3, #1	; 0x1
  100bb4:	e50b3014 	str	r3, [fp, #-20]
  100bb8:	e1a00002 	mov	r0, r2
  100bbc:	ebffffcd 	bl	100af8 <uart0_putc>
		i++;
  100bc0:	e51b3010 	ldr	r3, [fp, #-16]
  100bc4:	e2833001 	add	r3, r3, #1	; 0x1
  100bc8:	e50b3010 	str	r3, [fp, #-16]
  100bcc:	e51b3014 	ldr	r3, [fp, #-20]
  100bd0:	e5d33000 	ldrb	r3, [r3]
  100bd4:	e3530000 	cmp	r3, #0	; 0x0
  100bd8:	1afffff0 	bne	100ba0 <uart0_puts+0x20>
	}
	return i;
  100bdc:	e51b3010 	ldr	r3, [fp, #-16]
}
  100be0:	e1a00003 	mov	r0, r3
  100be4:	e24bd00c 	sub	sp, fp, #12	; 0xc
  100be8:	e89da800 	ldmia	sp, {fp, sp, pc}

00100bec <uart0_prints>:

int uart0_prints ( char* s )
{
  100bec:	e1a0c00d 	mov	ip, sp
  100bf0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  100bf4:	e24cb004 	sub	fp, ip, #4	; 0x4
  100bf8:	e24dd008 	sub	sp, sp, #8	; 0x8
  100bfc:	e50b0014 	str	r0, [fp, #-20]
	int i = 0;
  100c00:	e3a03000 	mov	r3, #0	; 0x0
  100c04:	e50b3010 	str	r3, [fp, #-16]
	while ( *s ) {
  100c08:	ea00000a 	b	100c38 <uart0_prints+0x4c>
		uart0_putchar( *s++ );
  100c0c:	e51b3014 	ldr	r3, [fp, #-20]
  100c10:	e5d33000 	ldrb	r3, [r3]
  100c14:	e1a02003 	mov	r2, r3
  100c18:	e51b3014 	ldr	r3, [fp, #-20]
  100c1c:	e2833001 	add	r3, r3, #1	; 0x1
  100c20:	e50b3014 	str	r3, [fp, #-20]
  100c24:	e1a00002 	mov	r0, r2
  100c28:	ebffffc5 	bl	100b44 <uart0_putchar>
		i++;
  100c2c:	e51b3010 	ldr	r3, [fp, #-16]
  100c30:	e2833001 	add	r3, r3, #1	; 0x1
  100c34:	e50b3010 	str	r3, [fp, #-16]
  100c38:	e51b3014 	ldr	r3, [fp, #-20]
  100c3c:	e5d33000 	ldrb	r3, [r3]
  100c40:	e3530000 	cmp	r3, #0	; 0x0
  100c44:	1afffff0 	bne	100c0c <uart0_prints+0x20>
	}
	return i;
  100c48:	e51b3010 	ldr	r3, [fp, #-16]
}
  100c4c:	e1a00003 	mov	r0, r3
  100c50:	e24bd00c 	sub	sp, fp, #12	; 0xc
  100c54:	e89da800 	ldmia	sp, {fp, sp, pc}

00100c58 <iFdvUart_kbhit>:

int iFdvUart_kbhit( void ) /* returns true if character in receive buffer */
{
  100c58:	e1a0c00d 	mov	ip, sp
  100c5c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  100c60:	e24cb004 	sub	fp, ip, #4	; 0x4
  100c64:	e24dd004 	sub	sp, sp, #4	; 0x4
	if ( pUSART->US_CSR & AT91C_US_RXRDY) {
  100c68:	e59f3034 	ldr	r3, [pc, #52]	; 100ca4 <.text+0xca4>
  100c6c:	e5933000 	ldr	r3, [r3]
  100c70:	e5933014 	ldr	r3, [r3, #20]
  100c74:	e2033001 	and	r3, r3, #1	; 0x1
  100c78:	e20330ff 	and	r3, r3, #255	; 0xff
  100c7c:	e3530000 	cmp	r3, #0	; 0x0
  100c80:	0a000002 	beq	100c90 <iFdvUart_kbhit+0x38>
		return 1;
  100c84:	e3a03001 	mov	r3, #1	; 0x1
  100c88:	e50b3010 	str	r3, [fp, #-16]
  100c8c:	ea000001 	b	100c98 <iFdvUart_kbhit+0x40>
	}
	else {
		return 0;
  100c90:	e3a03000 	mov	r3, #0	; 0x0
  100c94:	e50b3010 	str	r3, [fp, #-16]
  100c98:	e51b3010 	ldr	r3, [fp, #-16]
	}
}
  100c9c:	e1a00003 	mov	r0, r3
  100ca0:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
  100ca4:	00200004 	eoreq	r0, r0, r4

00100ca8 <uart0_getc>:

int uart0_getc ( void )  /* Read Character from Serial Port */
{    
  100ca8:	e1a0c00d 	mov	ip, sp
  100cac:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  100cb0:	e24cb004 	sub	fp, ip, #4	; 0x4
  while (!(pUSART->US_CSR & AT91C_US_RXRDY));   /* Wait for Full Rx Buffer */
  100cb4:	e59f3024 	ldr	r3, [pc, #36]	; 100ce0 <.text+0xce0>
  100cb8:	e5933000 	ldr	r3, [r3]
  100cbc:	e5933014 	ldr	r3, [r3, #20]
  100cc0:	e2033001 	and	r3, r3, #1	; 0x1
  100cc4:	e3530000 	cmp	r3, #0	; 0x0
  100cc8:	0afffff9 	beq	100cb4 <uart0_getc+0xc>
  return (pUSART->US_RHR);                      /* Read Character */
  100ccc:	e59f300c 	ldr	r3, [pc, #12]	; 100ce0 <.text+0xce0>
  100cd0:	e5933000 	ldr	r3, [r3]
  100cd4:	e5933018 	ldr	r3, [r3, #24]
}
  100cd8:	e1a00003 	mov	r0, r3
  100cdc:	e89da800 	ldmia	sp, {fp, sp, pc}
  100ce0:	00200004 	eoreq	r0, r0, r4

00100ce4 <ucFdvUart_GetByte>:


unsigned char ucFdvUart_GetByte(void)
{
  100ce4:	e1a0c00d 	mov	ip, sp
  100ce8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  100cec:	e24cb004 	sub	fp, ip, #4	; 0x4
	return (pUSART->US_RHR);                      /* Read Character */
  100cf0:	e59f3010 	ldr	r3, [pc, #16]	; 100d08 <.text+0xd08>
  100cf4:	e5933000 	ldr	r3, [r3]
  100cf8:	e5933018 	ldr	r3, [r3, #24]
  100cfc:	e20330ff 	and	r3, r3, #255	; 0xff
}
  100d00:	e1a00003 	mov	r0, r3
  100d04:	e89da800 	ldmia	sp, {fp, sp, pc}
  100d08:	00200004 	eoreq	r0, r0, r4

00100d0c <vFdvUart0_init>:



void vFdvUartSendPS2Byte( unsigned char );
//static unsigned char uc1,uc2;

void vFdvUart0_init (void) 
{                   /* Initialize Serial Interface */
  100d0c:	e1a0c00d 	mov	ip, sp
  100d10:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  100d14:	e24cb004 	sub	fp, ip, #4	; 0x4
  100d18:	e24dd008 	sub	sp, sp, #8	; 0x8
	  /* mt: n.b: uart0 clock must be enabled to use it */
	volatile unsigned int uiCount,uiDummy;
	

	  *AT91C_PIOA_PDR = AT91C_PA5_RXD0 ;        /* Enable RxD0 & SCK0 Pin */
  100d1c:	e3e03ebf 	mvn	r3, #3056	; 0xbf0
  100d20:	e243300b 	sub	r3, r3, #11	; 0xb
  100d24:	e3a02020 	mov	r2, #32	; 0x20
  100d28:	e5832000 	str	r2, [r3]

	  	// Disable interrupts
	  pUSART->US_IDR = (unsigned int) -1;
  100d2c:	e59f308c 	ldr	r3, [pc, #140]	; 100dc0 <.text+0xdc0>
  100d30:	e5932000 	ldr	r2, [r3]
  100d34:	e3e03000 	mvn	r3, #0	; 0x0
  100d38:	e582300c 	str	r3, [r2, #12]

	    // Timeguard disabled
	  pUSART->US_TTGR = 0;
  100d3c:	e59f307c 	ldr	r3, [pc, #124]	; 100dc0 <.text+0xdc0>
  100d40:	e5932000 	ldr	r2, [r3]
  100d44:	e3a03000 	mov	r3, #0	; 0x0
  100d48:	e5823028 	str	r3, [r2, #40]

	  
	  pUSART->US_CR = AT91C_US_RSTRX |          /* Reset Receiver      */
  100d4c:	e59f306c 	ldr	r3, [pc, #108]	; 100dc0 <.text+0xdc0>
  100d50:	e5932000 	ldr	r2, [r3]
  100d54:	e3a030ac 	mov	r3, #172	; 0xac
  100d58:	e5823000 	str	r3, [r2]
	                  AT91C_US_RSTTX |          /* Reset Transmitter   */
	                  AT91C_US_RXDIS |          /* Receiver Disable    */
	                  AT91C_US_TXDIS;           /* Transmitter Disable */

	  pUSART->US_MR = AT91C_US_USMODE_NORMAL |  /* Normal Mode */
  100d5c:	e59f305c 	ldr	r3, [pc, #92]	; 100dc0 <.text+0xdc0>
  100d60:	e5932000 	ldr	r2, [r3]
  100d64:	e3a03e3f 	mov	r3, #1008	; 0x3f0
  100d68:	e5823004 	str	r3, [r2, #4]
	  					AT91C_US_CLKS_EXT    |  /* Externalclock */
	                  AT91C_US_CHRL_8_BITS   |  /* 8-bit Data  */
	                  AT91C_US_PAR_ODD      |  /* Parity  Odd */
	                  AT91C_US_NBSTOP_1_BIT  | /* 1 Stop Bit  */
	                  AT91C_US_SYNC;    	 /*synchonous mode*/


	  	//* Reset receiver and transmitter
	      pUSART->US_CR = AT91C_US_RSTRX | AT91C_US_RSTTX ;
  100d6c:	e59f304c 	ldr	r3, [pc, #76]	; 100dc0 <.text+0xdc0>
  100d70:	e5932000 	ldr	r2, [r3]
  100d74:	e3a0300c 	mov	r3, #12	; 0xc
  100d78:	e5823000 	str	r3, [r2]
	  
//
	      vFdvUartSendPS2Byte(0xF4);
  100d7c:	e3a000f4 	mov	r0, #244	; 0xf4
  100d80:	eb00000f 	bl	100dc4 <vFdvUartSendPS2Byte>
	      
  	      for (uiCount=0;uiCount<500;uiCount++)
  100d84:	e3a03000 	mov	r3, #0	; 0x0
  100d88:	e50b3010 	str	r3, [fp, #-16]
  100d8c:	ea000005 	b	100da8 <vFdvUart0_init+0x9c>
  	      	uiDummy++;
  100d90:	e51b3014 	ldr	r3, [fp, #-20]
  100d94:	e2833001 	add	r3, r3, #1	; 0x1
  100d98:	e50b3014 	str	r3, [fp, #-20]
  100d9c:	e51b3010 	ldr	r3, [fp, #-16]
  100da0:	e2833001 	add	r3, r3, #1	; 0x1
  100da4:	e50b3010 	str	r3, [fp, #-16]
  100da8:	e51b2010 	ldr	r2, [fp, #-16]
  100dac:	e3a03e1f 	mov	r3, #496	; 0x1f0
  100db0:	e2833003 	add	r3, r3, #3	; 0x3
  100db4:	e1520003 	cmp	r2, r3
  100db8:	9afffff4 	bls	100d90 <vFdvUart0_init+0x84>
  	      

	      while( 1)
	    	  ;
  100dbc:	eafffffe 	b	100dbc <vFdvUart0_init+0xb0>
  100dc0:	00200004 	eoreq	r0, r0, r4

00100dc4 <vFdvUartSendPS2Byte>:
}


void vFdvUartSendPS2Byte( unsigned char ucData )
{
  100dc4:	e1a0c00d 	mov	ip, sp
  100dc8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  100dcc:	e24cb004 	sub	fp, ip, #4	; 0x4
  100dd0:	e24dd010 	sub	sp, sp, #16	; 0x10
  100dd4:	e1a03000 	mov	r3, r0
  100dd8:	e54b301c 	strb	r3, [fp, #-28]
	volatile unsigned int uiCount,uiDummy;
	unsigned char ucParityCount = 0;
  100ddc:	e3a03000 	mov	r3, #0	; 0x0
  100de0:	e54b300d 	strb	r3, [fp, #-13]
	
	 pUSART->US_CR =  AT91C_US_RXDIS ;          /* Receiver Disable    */
  100de4:	e59f320c 	ldr	r3, [pc, #524]	; 100ff8 <.text+0xff8>
  100de8:	e5932000 	ldr	r2, [r3]
  100dec:	e3a03020 	mov	r3, #32	; 0x20
  100df0:	e5823000 	str	r3, [r2]
      //set clock line low: configure pio tx has pio
      AT91F_PIO_CfgOutput(AT91C_BASE_PIOA,AT91C_PA2_SCK0);
  100df4:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
  100df8:	e1a009c0 	mov	r0, r0, asr #19
  100dfc:	e3a01004 	mov	r1, #4	; 0x4
  100e00:	eb00007d 	bl	100ffc <AT91F_PIO_CfgOutput>
      AT91C_BASE_PIOA->PIO_MDER = AT91C_PA2_SCK0;
  100e04:	e3a0320a 	mov	r3, #-1610612736	; 0xa0000000
  100e08:	e1a039c3 	mov	r3, r3, asr #19
  100e0c:	e3a02004 	mov	r2, #4	; 0x4
  100e10:	e5832050 	str	r2, [r3, #80]
      AT91F_PIO_ClearOutput(AT91C_BASE_PIOA,AT91C_PA2_SCK0);
  100e14:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
  100e18:	e1a009c0 	mov	r0, r0, asr #19
  100e1c:	e3a01004 	mov	r1, #4	; 0x4
  100e20:	eb000083 	bl	101034 <AT91F_PIO_ClearOutput>
      //wait 
      for (uiCount=0;uiCount<500;uiCount++)
  100e24:	e3a03000 	mov	r3, #0	; 0x0
  100e28:	e50b3014 	str	r3, [fp, #-20]
  100e2c:	ea000005 	b	100e48 <vFdvUartSendPS2Byte+0x84>
      	uiDummy++;
  100e30:	e51b3018 	ldr	r3, [fp, #-24]
  100e34:	e2833001 	add	r3, r3, #1	; 0x1
  100e38:	e50b3018 	str	r3, [fp, #-24]
  100e3c:	e51b3014 	ldr	r3, [fp, #-20]
  100e40:	e2833001 	add	r3, r3, #1	; 0x1
  100e44:	e50b3014 	str	r3, [fp, #-20]
  100e48:	e51b2014 	ldr	r2, [fp, #-20]
  100e4c:	e3a03e1f 	mov	r3, #496	; 0x1f0
  100e50:	e2833003 	add	r3, r3, #3	; 0x3
  100e54:	e1520003 	cmp	r2, r3
  100e58:	9afffff4 	bls	100e30 <vFdvUartSendPS2Byte+0x6c>
      AT91F_PIO_CfgOutput(AT91C_BASE_PIOA,AT91C_PIO_PA6);
  100e5c:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
  100e60:	e1a009c0 	mov	r0, r0, asr #19
  100e64:	e3a01040 	mov	r1, #64	; 0x40
  100e68:	eb000063 	bl	100ffc <AT91F_PIO_CfgOutput>
      AT91C_BASE_PIOA->PIO_MDER = AT91C_PIO_PA6;
  100e6c:	e3a0320a 	mov	r3, #-1610612736	; 0xa0000000
  100e70:	e1a039c3 	mov	r3, r3, asr #19
  100e74:	e3a02040 	mov	r2, #64	; 0x40
  100e78:	e5832050 	str	r2, [r3, #80]
      AT91F_PIO_ClearOutput(AT91C_BASE_PIOA,AT91C_PIO_PA6);
  100e7c:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
  100e80:	e1a009c0 	mov	r0, r0, asr #19
  100e84:	e3a01040 	mov	r1, #64	; 0x40
  100e88:	eb000069 	bl	101034 <AT91F_PIO_ClearOutput>
      AT91F_PIO_SetOutput(AT91C_BASE_PIOA,AT91C_PA2_SCK0);
  100e8c:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
  100e90:	e1a009c0 	mov	r0, r0, asr #19
  100e94:	e3a01004 	mov	r1, #4	; 0x4
  100e98:	eb000070 	bl	101060 <AT91F_PIO_SetOutput>
      AT91F_PIO_CfgInput(AT91C_BASE_PIOA,AT91C_PA2_SCK0);
  100e9c:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
  100ea0:	e1a009c0 	mov	r0, r0, asr #19
  100ea4:	e3a01004 	mov	r1, #4	; 0x4
  100ea8:	eb000077 	bl	10108c <AT91F_PIO_CfgInput>
      
      for (uiCount=0;uiCount<8;uiCount++)
  100eac:	e3a03000 	mov	r3, #0	; 0x0
  100eb0:	e50b3014 	str	r3, [fp, #-20]
  100eb4:	ea000022 	b	100f44 <vFdvUartSendPS2Byte+0x180>
      {
    	  //wait clock line low
    	  while( (AT91C_BASE_PIOA->PIO_PDSR)&AT91C_PA2_SCK0)
  100eb8:	e3a0320a 	mov	r3, #-1610612736	; 0xa0000000
  100ebc:	e1a039c3 	mov	r3, r3, asr #19
  100ec0:	e593303c 	ldr	r3, [r3, #60]
  100ec4:	e2033004 	and	r3, r3, #4	; 0x4
  100ec8:	e3530000 	cmp	r3, #0	; 0x0
  100ecc:	1afffff9 	bne	100eb8 <vFdvUartSendPS2Byte+0xf4>
    		  ;
    	  //set data line level
    	  if( ucData & 0x1 )
  100ed0:	e55b301c 	ldrb	r3, [fp, #-28]
  100ed4:	e2033001 	and	r3, r3, #1	; 0x1
  100ed8:	e20330ff 	and	r3, r3, #255	; 0xff
  100edc:	e3530000 	cmp	r3, #0	; 0x0
  100ee0:	0a000007 	beq	100f04 <vFdvUartSendPS2Byte+0x140>
    	  {
    		ucParityCount++;
  100ee4:	e55b300d 	ldrb	r3, [fp, #-13]
  100ee8:	e2833001 	add	r3, r3, #1	; 0x1
  100eec:	e54b300d 	strb	r3, [fp, #-13]
    		AT91C_BASE_PIOA->PIO_SODR = AT91C_PA6_TXD0;
  100ef0:	e3a0320a 	mov	r3, #-1610612736	; 0xa0000000
  100ef4:	e1a039c3 	mov	r3, r3, asr #19
  100ef8:	e3a02040 	mov	r2, #64	; 0x40
  100efc:	e5832030 	str	r2, [r3, #48]
  100f00:	ea000003 	b	100f14 <vFdvUartSendPS2Byte+0x150>
    	  }
    	  else
    		AT91C_BASE_PIOA->PIO_CODR = AT91C_PA6_TXD0;
  100f04:	e3a0320a 	mov	r3, #-1610612736	; 0xa0000000
  100f08:	e1a039c3 	mov	r3, r3, asr #19
  100f0c:	e3a02040 	mov	r2, #64	; 0x40
  100f10:	e5832034 	str	r2, [r3, #52]
    	  ucData>>=1;
  100f14:	e55b301c 	ldrb	r3, [fp, #-28]
  100f18:	e1a030a3 	mov	r3, r3, lsr #1
  100f1c:	e54b301c 	strb	r3, [fp, #-28]
    	//wait clock line high
    	  while( !((AT91C_BASE_PIOA->PIO_PDSR)&AT91C_PA2_SCK0))
  100f20:	e3a0320a 	mov	r3, #-1610612736	; 0xa0000000
  100f24:	e1a039c3 	mov	r3, r3, asr #19
  100f28:	e593303c 	ldr	r3, [r3, #60]
  100f2c:	e2033004 	and	r3, r3, #4	; 0x4
  100f30:	e3530000 	cmp	r3, #0	; 0x0
  100f34:	0afffff9 	beq	100f20 <vFdvUartSendPS2Byte+0x15c>
  100f38:	e51b3014 	ldr	r3, [fp, #-20]
  100f3c:	e2833001 	add	r3, r3, #1	; 0x1
  100f40:	e50b3014 	str	r3, [fp, #-20]
  100f44:	e51b3014 	ldr	r3, [fp, #-20]
  100f48:	e3530007 	cmp	r3, #7	; 0x7
  100f4c:	9affffd9 	bls	100eb8 <vFdvUartSendPS2Byte+0xf4>
    		  ;
      }
      //wait clock line low
      while( (AT91C_BASE_PIOA->PIO_PDSR)&AT91C_PA2_SCK0)
  100f50:	e3a0320a 	mov	r3, #-1610612736	; 0xa0000000
  100f54:	e1a039c3 	mov	r3, r3, asr #19
  100f58:	e593303c 	ldr	r3, [r3, #60]
  100f5c:	e2033004 	and	r3, r3, #4	; 0x4
  100f60:	e3530000 	cmp	r3, #0	; 0x0
  100f64:	1afffff9 	bne	100f50 <vFdvUartSendPS2Byte+0x18c>
		  ;
      //parity: 
      if( ucParityCount & 0x1 )
  100f68:	e55b300d 	ldrb	r3, [fp, #-13]
  100f6c:	e2033001 	and	r3, r3, #1	; 0x1
  100f70:	e20330ff 	and	r3, r3, #255	; 0xff
  100f74:	e3530000 	cmp	r3, #0	; 0x0
  100f78:	0a000004 	beq	100f90 <vFdvUartSendPS2Byte+0x1cc>
    	  AT91C_BASE_PIOA->PIO_CODR = AT91C_PA6_TXD0;
  100f7c:	e3a0320a 	mov	r3, #-1610612736	; 0xa0000000
  100f80:	e1a039c3 	mov	r3, r3, asr #19
  100f84:	e3a02040 	mov	r2, #64	; 0x40
  100f88:	e5832034 	str	r2, [r3, #52]
  100f8c:	ea000003 	b	100fa0 <vFdvUartSendPS2Byte+0x1dc>
	  else
    	  AT91C_BASE_PIOA->PIO_SODR = AT91C_PA6_TXD0;
  100f90:	e3a0320a 	mov	r3, #-1610612736	; 0xa0000000
  100f94:	e1a039c3 	mov	r3, r3, asr #19
  100f98:	e3a02040 	mov	r2, #64	; 0x40
  100f9c:	e5832030 	str	r2, [r3, #48]
	  //wait clock line high
	  while( !((AT91C_BASE_PIOA->PIO_PDSR)&AT91C_PA2_SCK0))
  100fa0:	e3a0320a 	mov	r3, #-1610612736	; 0xa0000000
  100fa4:	e1a039c3 	mov	r3, r3, asr #19
  100fa8:	e593303c 	ldr	r3, [r3, #60]
  100fac:	e2033004 	and	r3, r3, #4	; 0x4
  100fb0:	e3530000 	cmp	r3, #0	; 0x0
  100fb4:	0afffff9 	beq	100fa0 <vFdvUartSendPS2Byte+0x1dc>
  		  ;
	  //wait clock line low
	  while( (AT91C_BASE_PIOA->PIO_PDSR)&AT91C_PA2_SCK0)
  100fb8:	e3a0320a 	mov	r3, #-1610612736	; 0xa0000000
  100fbc:	e1a039c3 	mov	r3, r3, asr #19
  100fc0:	e593303c 	ldr	r3, [r3, #60]
  100fc4:	e2033004 	and	r3, r3, #4	; 0x4
  100fc8:	e3530000 	cmp	r3, #0	; 0x0
  100fcc:	1afffff9 	bne	100fb8 <vFdvUartSendPS2Byte+0x1f4>
		  ;
      //stop bit:level 1 <=> cfg input
	  AT91F_PIO_CfgInput(AT91C_BASE_PIOA,AT91C_PA6_TXD0);
  100fd0:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
  100fd4:	e1a009c0 	mov	r0, r0, asr #19
  100fd8:	e3a01040 	mov	r1, #64	; 0x40
  100fdc:	eb00002a 	bl	10108c <AT91F_PIO_CfgInput>
	  /* Receiver Enable     */
      pUSART->US_CR = AT91C_US_RXEN ;         
  100fe0:	e59f3010 	ldr	r3, [pc, #16]	; 100ff8 <.text+0xff8>
  100fe4:	e5932000 	ldr	r2, [r3]
  100fe8:	e3a03010 	mov	r3, #16	; 0x10
  100fec:	e5823000 	str	r3, [r2]
}
  100ff0:	e24bd00c 	sub	sp, fp, #12	; 0xc
  100ff4:	e89da800 	ldmia	sp, {fp, sp, pc}
  100ff8:	00200004 	eoreq	r0, r0, r4

00100ffc <AT91F_PIO_CfgOutput>:
//*----------------------------------------------------------------------------
static __inline void AT91F_PIO_CfgOutput(
	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
	unsigned int pioEnable)      // \arg PIO to be enabled
{
  100ffc:	e1a0c00d 	mov	ip, sp
  101000:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  101004:	e24cb004 	sub	fp, ip, #4	; 0x4
  101008:	e24dd008 	sub	sp, sp, #8	; 0x8
  10100c:	e50b0010 	str	r0, [fp, #-16]
  101010:	e50b1014 	str	r1, [fp, #-20]
	pPio->PIO_PER = pioEnable; // Set in PIO mode
  101014:	e51b2010 	ldr	r2, [fp, #-16]
  101018:	e51b3014 	ldr	r3, [fp, #-20]
  10101c:	e5823000 	str	r3, [r2]
	pPio->PIO_OER = pioEnable; // Configure in Output
  101020:	e51b2010 	ldr	r2, [fp, #-16]
  101024:	e51b3014 	ldr	r3, [fp, #-20]
  101028:	e5823010 	str	r3, [r2, #16]
}
  10102c:	e24bd00c 	sub	sp, fp, #12	; 0xc
  101030:	e89da800 	ldmia	sp, {fp, sp, pc}

00101034 <AT91F_PIO_ClearOutput>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_CfgInput
//* \brief Enable PIO in input mode
//*----------------------------------------------------------------------------
static __inline void AT91F_PIO_CfgInput(
	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
	unsigned int inputEnable)      // \arg PIO to be enabled
{
	// Disable output
	pPio->PIO_ODR  = inputEnable;
	pPio->PIO_PER  = inputEnable;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_CfgOpendrain
//* \brief Configure PIO in open drain
//*----------------------------------------------------------------------------
static __inline void AT91F_PIO_CfgOpendrain(
	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
	unsigned int multiDrvEnable) // \arg pio to be configured in open drain
{
	// Configure the multi-drive option
	pPio->PIO_MDDR = ~multiDrvEnable;
	pPio->PIO_MDER = multiDrvEnable;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_CfgPullup
//* \brief Enable pullup on PIO
//*----------------------------------------------------------------------------
static __inline void AT91F_PIO_CfgPullup(
	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
	unsigned int pullupEnable)   // \arg enable pullup on PIO
{
		// Connect or not Pullup
	pPio->PIO_PPUDR = ~pullupEnable;
	pPio->PIO_PPUER = pullupEnable;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_CfgDirectDrive
//* \brief Enable direct drive on PIO
//*----------------------------------------------------------------------------
static __inline void AT91F_PIO_CfgDirectDrive(
	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
	unsigned int directDrive)    // \arg PIO to be configured with direct drive

{
	// Configure the Direct Drive
	pPio->PIO_OWDR  = ~directDrive;
	pPio->PIO_OWER  = directDrive;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_CfgInputFilter
//* \brief Enable input filter on input PIO
//*----------------------------------------------------------------------------
static __inline void AT91F_PIO_CfgInputFilter(
	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
	unsigned int inputFilter)    // \arg PIO to be configured with input filter

{
	// Configure the Direct Drive
	pPio->PIO_IFDR  = ~inputFilter;
	pPio->PIO_IFER  = inputFilter;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_GetInput
//* \brief Return PIO input value
//*----------------------------------------------------------------------------
static __inline unsigned int AT91F_PIO_GetInput( // \return PIO input
	AT91PS_PIO pPio) // \arg  pointer to a PIO controller
{
	return pPio->PIO_PDSR;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_IsInputSet
//* \brief Test if PIO is input flag is active
//*----------------------------------------------------------------------------
static __inline int AT91F_PIO_IsInputSet(
	AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
	unsigned int flag) // \arg  flag to be tested
{
	return (AT91F_PIO_GetInput(pPio) & flag);
}


//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_SetOutput
//* \brief Set to 1 output PIO
//*----------------------------------------------------------------------------
static __inline void AT91F_PIO_SetOutput(
	AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
	unsigned int flag) // \arg  output to be set
{
	pPio->PIO_SODR = flag;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_ClearOutput
//* \brief Set to 0 output PIO
//*----------------------------------------------------------------------------
static __inline void AT91F_PIO_ClearOutput(
	AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
	unsigned int flag) // \arg  output to be cleared
{
  101034:	e1a0c00d 	mov	ip, sp
  101038:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  10103c:	e24cb004 	sub	fp, ip, #4	; 0x4
  101040:	e24dd008 	sub	sp, sp, #8	; 0x8
  101044:	e50b0010 	str	r0, [fp, #-16]
  101048:	e50b1014 	str	r1, [fp, #-20]
	pPio->PIO_CODR = flag;
  10104c:	e51b2010 	ldr	r2, [fp, #-16]
  101050:	e51b3014 	ldr	r3, [fp, #-20]
  101054:	e5823034 	str	r3, [r2, #52]
}
  101058:	e24bd00c 	sub	sp, fp, #12	; 0xc
  10105c:	e89da800 	ldmia	sp, {fp, sp, pc}

00101060 <AT91F_PIO_SetOutput>:
  101060:	e1a0c00d 	mov	ip, sp
  101064:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  101068:	e24cb004 	sub	fp, ip, #4	; 0x4
  10106c:	e24dd008 	sub	sp, sp, #8	; 0x8
  101070:	e50b0010 	str	r0, [fp, #-16]
  101074:	e50b1014 	str	r1, [fp, #-20]
  101078:	e51b2010 	ldr	r2, [fp, #-16]
  10107c:	e51b3014 	ldr	r3, [fp, #-20]
  101080:	e5823030 	str	r3, [r2, #48]
  101084:	e24bd00c 	sub	sp, fp, #12	; 0xc
  101088:	e89da800 	ldmia	sp, {fp, sp, pc}

0010108c <AT91F_PIO_CfgInput>:
  10108c:	e1a0c00d 	mov	ip, sp
  101090:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  101094:	e24cb004 	sub	fp, ip, #4	; 0x4
  101098:	e24dd008 	sub	sp, sp, #8	; 0x8
  10109c:	e50b0010 	str	r0, [fp, #-16]
  1010a0:	e50b1014 	str	r1, [fp, #-20]
  1010a4:	e51b2010 	ldr	r2, [fp, #-16]
  1010a8:	e51b3014 	ldr	r3, [fp, #-20]
  1010ac:	e5823014 	str	r3, [r2, #20]
  1010b0:	e51b2010 	ldr	r2, [fp, #-16]
  1010b4:	e51b3014 	ldr	r3, [fp, #-20]
  1010b8:	e5823000 	str	r3, [r2]
  1010bc:	e24bd00c 	sub	sp, fp, #12	; 0xc
  1010c0:	e89da800 	ldmia	sp, {fp, sp, pc}

001010c4 <vFdvTimer_init>:
  ISR_EXIT();
}


void vFdvTimer_init(void) {                    /* Setup PIT with Interrupt */
  1010c4:	e1a0c00d 	mov	ip, sp
  1010c8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  1010cc:	e24cb004 	sub	fp, ip, #4	; 0x4
  1010d0:	e24dd004 	sub	sp, sp, #4	; 0x4
  volatile AT91S_AIC * pAIC = AT91C_BASE_AIC;
  1010d4:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
  1010d8:	e1a039c3 	mov	r3, r3, asr #19
  1010dc:	e50b3010 	str	r3, [fp, #-16]

  //*AT91C_PIOA_CODR = LED3; 

  *AT91C_PITC_PIMR = AT91C_PITC_PITIEN |    /* PIT Interrupt Enable */ 
  1010e0:	e3a024a6 	mov	r2, #-1509949440	; 0xa6000000
  1010e4:	e1a02ac2 	mov	r2, r2, asr #21
  1010e8:	e3a03403 	mov	r3, #50331648	; 0x3000000
  1010ec:	e2833ebb 	add	r3, r3, #2992	; 0xbb0
  1010f0:	e283300a 	add	r3, r3, #10	; 0xa
  1010f4:	e5823000 	str	r3, [r2]
                     AT91C_PITC_PITEN  |    /* PIT Enable */
                     PIV;                   /* Periodic Interval Value */ 

  /* Setup System Interrupt Mode and Vector with Priority 7 and Enable it */
  // mt pAIC->AIC_SMR[AT91C_ID_SYS] = AT91C_AIC_SRCTYPE_INT_EDGE_TRIGGERED | 7;
  pAIC->AIC_SMR[AT91C_ID_SYS] = AT91C_AIC_SRCTYPE_INT_POSITIVE_EDGE | 7;
  1010f8:	e51b2010 	ldr	r2, [fp, #-16]
  1010fc:	e3a03027 	mov	r3, #39	; 0x27
  101100:	e5823004 	str	r3, [r2, #4]
  
  pAIC->AIC_SVR[AT91C_ID_SYS] = (unsigned long) system_int;
  101104:	e59f3018 	ldr	r3, [pc, #24]	; 101124 <.text+0x1124>
  101108:	e1a02003 	mov	r2, r3
  10110c:	e51b3010 	ldr	r3, [fp, #-16]
  101110:	e5832084 	str	r2, [r3, #132]
  pAIC->AIC_IECR = (1 << AT91C_ID_SYS);
  101114:	e51b2010 	ldr	r2, [fp, #-16]
  101118:	e3a03002 	mov	r3, #2	; 0x2
  10111c:	e5823120 	str	r3, [r2, #288]
  
  //*AT91C_PIOA_CODR = LED2; 
  
}
  101120:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
  101124:	00200824 	eoreq	r0, r0, r4, lsr #16

00101128 <dvTimerwait>:

void dvTimerwait(unsigned long time)
{
  101128:	e1a0c00d 	mov	ip, sp
  10112c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  101130:	e24cb004 	sub	fp, ip, #4	; 0x4
  101134:	e24dd008 	sub	sp, sp, #8	; 0x8
  101138:	e50b0014 	str	r0, [fp, #-20]
	unsigned long tick;
	
	tick = timeval;
  10113c:	e59f3028 	ldr	r3, [pc, #40]	; 10116c <.text+0x116c>
  101140:	e5933000 	ldr	r3, [r3]
  101144:	e50b3010 	str	r3, [fp, #-16]
	
	/* Wait for specified Time */
	while ((unsigned long)(timeval - tick) < time);
  101148:	e59f301c 	ldr	r3, [pc, #28]	; 10116c <.text+0x116c>
  10114c:	e5932000 	ldr	r2, [r3]
  101150:	e51b3010 	ldr	r3, [fp, #-16]
  101154:	e0632002 	rsb	r2, r3, r2
  101158:	e51b3014 	ldr	r3, [fp, #-20]
  10115c:	e1520003 	cmp	r2, r3
  101160:	3afffff8 	bcc	101148 <dvTimerwait+0x20>
}
  101164:	e24bd00c 	sub	sp, fp, #12	; 0xc
  101168:	e89da800 	ldmia	sp, {fp, sp, pc}
  10116c:	00200a0c 	eoreq	r0, r0, ip, lsl #20

00101170 <AT91_spiSetSpeed>:
 BYTE Timer;			/* 100Hz decrement timer */


void AT91_spiSetSpeed(BYTE speed)
{
  101170:	e1a0c00d 	mov	ip, sp
  101174:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  101178:	e24cb004 	sub	fp, ip, #4	; 0x4
  10117c:	e24dd008 	sub	sp, sp, #8	; 0x8
  101180:	e1a03000 	mov	r3, r0
  101184:	e54b3014 	strb	r3, [fp, #-20]
	DWORD reg;

	if ( speed < SPI_SCBR_MIN ) 
  101188:	e55b3014 	ldrb	r3, [fp, #-20]
  10118c:	e3530001 	cmp	r3, #1	; 0x1
  101190:	8a000001 	bhi	10119c <AT91_spiSetSpeed+0x2c>
		speed = SPI_SCBR_MIN;
  101194:	e3a03002 	mov	r3, #2	; 0x2
  101198:	e54b3014 	strb	r3, [fp, #-20]
	if ( speed > 1 ) 
  10119c:	e55b3014 	ldrb	r3, [fp, #-20]
  1011a0:	e3530001 	cmp	r3, #1	; 0x1
  1011a4:	9a000004 	bls	1011bc <AT91_spiSetSpeed+0x4c>
		speed &= 0xFE;
  1011a8:	e3e03001 	mvn	r3, #1	; 0x1
  1011ac:	e1a02003 	mov	r2, r3
  1011b0:	e55b3014 	ldrb	r3, [fp, #-20]
  1011b4:	e0033002 	and	r3, r3, r2
  1011b8:	e54b3014 	strb	r3, [fp, #-20]

	reg = pSPI->SPI_CSR[SPI_CSR_NUM];
  1011bc:	e59f3038 	ldr	r3, [pc, #56]	; 1011fc <.text+0x11fc>
  1011c0:	e5933000 	ldr	r3, [r3]
  1011c4:	e5933030 	ldr	r3, [r3, #48]
  1011c8:	e50b3010 	str	r3, [fp, #-16]
	reg = ( reg & ~(AT91C_SPI_SCBR) ) | ( (DWORD)speed << 8 );
  1011cc:	e51b3010 	ldr	r3, [fp, #-16]
  1011d0:	e3c32cff 	bic	r2, r3, #65280	; 0xff00
  1011d4:	e55b3014 	ldrb	r3, [fp, #-20]
  1011d8:	e1a03403 	mov	r3, r3, lsl #8
  1011dc:	e1823003 	orr	r3, r2, r3
  1011e0:	e50b3010 	str	r3, [fp, #-16]
	pSPI->SPI_CSR[SPI_CSR_NUM] = reg;
  1011e4:	e59f3010 	ldr	r3, [pc, #16]	; 1011fc <.text+0x11fc>
  1011e8:	e5932000 	ldr	r2, [r3]
  1011ec:	e51b3010 	ldr	r3, [fp, #-16]
  1011f0:	e5823030 	str	r3, [r2, #48]
}
  1011f4:	e24bd00c 	sub	sp, fp, #12	; 0xc
  1011f8:	e89da800 	ldmia	sp, {fp, sp, pc}
  1011fc:	0020000c 	eoreq	r0, r0, ip

00101200 <AT91_spi>:

BYTE AT91_spi(BYTE outgoing)
{
  101200:	e1a0c00d 	mov	ip, sp
  101204:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  101208:	e24cb004 	sub	fp, ip, #4	; 0x4
  10120c:	e24dd008 	sub	sp, sp, #8	; 0x8
  101210:	e1a03000 	mov	r3, r0
  101214:	e54b3014 	strb	r3, [fp, #-20]
	BYTE incoming;

	while( !( pSPI->SPI_SR & AT91C_SPI_TDRE ) ); // transfer compl. wait
  101218:	e59f3058 	ldr	r3, [pc, #88]	; 101278 <.text+0x1278>
  10121c:	e5933000 	ldr	r3, [r3]
  101220:	e5933010 	ldr	r3, [r3, #16]
  101224:	e2033002 	and	r3, r3, #2	; 0x2
  101228:	e3530000 	cmp	r3, #0	; 0x0
  10122c:	0afffff9 	beq	101218 <AT91_spi+0x18>
	pSPI->SPI_TDR = (WORD)( outgoing );
  101230:	e59f3040 	ldr	r3, [pc, #64]	; 101278 <.text+0x1278>
  101234:	e5932000 	ldr	r2, [r3]
  101238:	e55b3014 	ldrb	r3, [fp, #-20]
  10123c:	e582300c 	str	r3, [r2, #12]
	while( !( pSPI->SPI_SR & AT91C_SPI_RDRF ) ); // wait for char
  101240:	e59f3030 	ldr	r3, [pc, #48]	; 101278 <.text+0x1278>
  101244:	e5933000 	ldr	r3, [r3]
  101248:	e5933010 	ldr	r3, [r3, #16]
  10124c:	e2033001 	and	r3, r3, #1	; 0x1
  101250:	e3530000 	cmp	r3, #0	; 0x0
  101254:	0afffff9 	beq	101240 <AT91_spi+0x40>
	incoming = (BYTE)( pSPI->SPI_RDR );
  101258:	e59f3018 	ldr	r3, [pc, #24]	; 101278 <.text+0x1278>
  10125c:	e5933000 	ldr	r3, [r3]
  101260:	e5933008 	ldr	r3, [r3, #8]
  101264:	e54b300d 	strb	r3, [fp, #-13]

	return incoming;
  101268:	e55b300d 	ldrb	r3, [fp, #-13]
}
  10126c:	e1a00003 	mov	r0, r3
  101270:	e24bd00c 	sub	sp, fp, #12	; 0xc
  101274:	e89da800 	ldmia	sp, {fp, sp, pc}
  101278:	0020000c 	eoreq	r0, r0, ip

0010127c <xmit_spi>:

/*--------------------------------*/
/* Transmit a byte to MMC via SPI */
/* (Platform dependent)           */

void xmit_spi(BYTE dat)
{
  10127c:	e1a0c00d 	mov	ip, sp
  101280:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  101284:	e24cb004 	sub	fp, ip, #4	; 0x4
  101288:	e24dd004 	sub	sp, sp, #4	; 0x4
  10128c:	e1a03000 	mov	r3, r0
  101290:	e54b3010 	strb	r3, [fp, #-16]
	AT91_spi(dat);
  101294:	e55b3010 	ldrb	r3, [fp, #-16]
  101298:	e1a00003 	mov	r0, r3
  10129c:	ebffffd7 	bl	101200 <AT91_spi>
}
  1012a0:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

001012a4 <rcvr_spi>:

/*---------------------------------*/
/* Receive a byte from MMC via SPI */
/* (Platform dependent)            */

BYTE rcvr_spi(void)
{
  1012a4:	e1a0c00d 	mov	ip, sp
  1012a8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  1012ac:	e24cb004 	sub	fp, ip, #4	; 0x4
	return AT91_spi(0xff);
  1012b0:	e3a000ff 	mov	r0, #255	; 0xff
  1012b4:	ebffffd1 	bl	101200 <AT91_spi>
  1012b8:	e1a03000 	mov	r3, r0
}
  1012bc:	e1a00003 	mov	r0, r3
  1012c0:	e89da800 	ldmia	sp, {fp, sp, pc}

001012c4 <rcvr_spi_m>:

/* Alternative "macro" (not at AT91 so far) to receive data fast */
void rcvr_spi_m(BYTE *dst)
{
  1012c4:	e1a0c00d 	mov	ip, sp
  1012c8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  1012cc:	e24cb004 	sub	fp, ip, #4	; 0x4
  1012d0:	e24dd004 	sub	sp, sp, #4	; 0x4
  1012d4:	e50b0010 	str	r0, [fp, #-16]
	*dst = rcvr_spi();
  1012d8:	ebfffff1 	bl	1012a4 <rcvr_spi>
  1012dc:	e1a03000 	mov	r3, r0
  1012e0:	e51b2010 	ldr	r2, [fp, #-16]
  1012e4:	e5c23000 	strb	r3, [r2]
}
  1012e8:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

001012ec <wait_ready>:


/*---------------------*/
/* Wait for card ready */
BYTE wait_ready ()
{
  1012ec:	e1a0c00d 	mov	ip, sp
  1012f0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  1012f4:	e24cb004 	sub	fp, ip, #4	; 0x4
  1012f8:	e24dd004 	sub	sp, sp, #4	; 0x4
	BYTE res;
	
	Timer = 50;			/* Wait for ready in timeout of 500ms */
  1012fc:	e59f3040 	ldr	r3, [pc, #64]	; 101344 <.text+0x1344>
  101300:	e3a02032 	mov	r2, #50	; 0x32
  101304:	e5c32000 	strb	r2, [r3]
	rcvr_spi();
  101308:	ebffffe5 	bl	1012a4 <rcvr_spi>
	do
		res = rcvr_spi();
  10130c:	ebffffe4 	bl	1012a4 <rcvr_spi>
  101310:	e1a03000 	mov	r3, r0
  101314:	e54b300d 	strb	r3, [fp, #-13]
	while ((res != 0xFF) && Timer);
  101318:	e55b300d 	ldrb	r3, [fp, #-13]
  10131c:	e35300ff 	cmp	r3, #255	; 0xff
  101320:	0a000004 	beq	101338 <wait_ready+0x4c>
  101324:	e59f3018 	ldr	r3, [pc, #24]	; 101344 <.text+0x1344>
  101328:	e5d33000 	ldrb	r3, [r3]
  10132c:	e20330ff 	and	r3, r3, #255	; 0xff
  101330:	e3530000 	cmp	r3, #0	; 0x0
  101334:	1afffff4 	bne	10130c <wait_ready+0x20>
	return res;
  101338:	e55b300d 	ldrb	r3, [fp, #-13]
}
  10133c:	e1a00003 	mov	r0, r3
  101340:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
  101344:	002009d0 	ldreqd	r0, [r0], -r0

00101348 <vFdvSpi_Init>:






/*-----------------------------------------------------------------------*/
/* Public Functions                                                      */


/*-----------------------*/
/* Initialize Disk Drive */
/* (Platform dependent)  */

void vFdvSpi_Init( void )
{
  101348:	e1a0c00d 	mov	ip, sp
  10134c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  101350:	e24cb004 	sub	fp, ip, #4	; 0x4
	// disable PIO from controlling MOSI, MISO, SCK (=hand over to SPI)
	// keep CS untouched - used as GPIO pin during init
	pPIOA->PIO_PDR = AT91C_PA12_MISO | AT91C_PA13_MOSI | AT91C_PA14_SPCK|AT91C_PA11_NPCS0; //  | NCPS_PDR_BIT;
  101354:	e59f3080 	ldr	r3, [pc, #128]	; 1013dc <.text+0x13dc>
  101358:	e5932000 	ldr	r2, [r3]
  10135c:	e3a03b1e 	mov	r3, #30720	; 0x7800
  101360:	e5823004 	str	r3, [r2, #4]
	// set pin-functions in PIO Controller
	pPIOA->PIO_ASR = AT91C_PA12_MISO | AT91C_PA13_MOSI | AT91C_PA14_SPCK|AT91C_PA11_NPCS0; /// not here: | NCPS_ASR_BIT;
  101364:	e59f3070 	ldr	r3, [pc, #112]	; 1013dc <.text+0x13dc>
  101368:	e5932000 	ldr	r2, [r3]
  10136c:	e3a03b1e 	mov	r3, #30720	; 0x7800
  101370:	e5823070 	str	r3, [r2, #112]
	

	// enable peripheral clock for SPI ( PID Bit 5 )
	AT91F_PMC_EnablePeriphClock(AT91C_BASE_PMC,1 << AT91C_ID_SPI  );
  101374:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
  101378:	e1a00ac0 	mov	r0, r0, asr #21
  10137c:	e3a01020 	mov	r1, #32	; 0x20
  101380:	eb000017 	bl	1013e4 <AT91F_PMC_EnablePeriphClock>
	//pPMC->PMC_PCER = ( (DWORD) 1 << AT91C_ID_SPI ); // n.b. IDs are just bit-numbers
	
	// SPI enable and reset
	AT91F_SPI_Reset(AT91C_BASE_SPI);
  101384:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
  101388:	e1a00740 	mov	r0, r0, asr #14
  10138c:	eb00001f 	bl	101410 <AT91F_SPI_Reset>
	AT91F_SPI_Enable(AT91C_BASE_SPI);
  101390:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
  101394:	e1a00740 	mov	r0, r0, asr #14
  101398:	eb000025 	bl	101434 <AT91F_SPI_Enable>
	//pSPI->SPI_CR = AT91C_SPI_SPIEN | AT91C_SPI_SWRST;
	
	// SPI mode: master, FDIV=0, fault detection disabled
	AT91F_SPI_CfgMode(AT91C_BASE_SPI,AT91C_SPI_MSTR | AT91C_SPI_MODFDIS);
  10139c:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
  1013a0:	e1a00740 	mov	r0, r0, asr #14
  1013a4:	e3a01011 	mov	r1, #17	; 0x11
  1013a8:	eb00002a 	bl	101458 <AT91F_SPI_CfgMode>
	//pSPI->SPI_MR  = AT91C_SPI_MSTR | AT91C_SPI_MODFDIS;
	
	// set chip-select-register
	// 8 bits per transfer, CPOL=1, ClockPhase=0, DLYBCT = 0
	AT91F_SPI_CfgCs(AT91C_BASE_SPI ,SPI_CSR_NUM, AT91C_SPI_CPOL | AT91C_SPI_BITS_8);
  1013ac:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
  1013b0:	e1a00740 	mov	r0, r0, asr #14
  1013b4:	e3a01000 	mov	r1, #0	; 0x0
  1013b8:	e3a02001 	mov	r2, #1	; 0x1
  1013bc:	eb000030 	bl	101484 <AT91F_SPI_CfgCs>
	//pSPI->SPI_CSR[SPI_CSR_NUM] = AT91C_SPI_CPOL | AT91C_SPI_BITS_8;
	
	// slow during init
	AT91_spiSetSpeed(0xFE); 
  1013c0:	e3a000fe 	mov	r0, #254	; 0xfe
  1013c4:	ebffff69 	bl	101170 <AT91_spiSetSpeed>
	
	// enable
	pSPI->SPI_CR = AT91C_SPI_SPIEN;
  1013c8:	e59f3010 	ldr	r3, [pc, #16]	; 1013e0 <.text+0x13e0>
  1013cc:	e5932000 	ldr	r2, [r3]
  1013d0:	e3a03001 	mov	r3, #1	; 0x1
  1013d4:	e5823000 	str	r3, [r2]

}
  1013d8:	e89da800 	ldmia	sp, {fp, sp, pc}
  1013dc:	00200008 	eoreq	r0, r0, r8
  1013e0:	0020000c 	eoreq	r0, r0, ip

001013e4 <AT91F_PMC_EnablePeriphClock>:
//*----------------------------------------------------------------------------
static __inline void AT91F_PMC_EnablePeriphClock (
	AT91PS_PMC pPMC, // \arg pointer to PMC controller
	unsigned int periphIds)  // \arg IDs of peripherals to enable
{
  1013e4:	e1a0c00d 	mov	ip, sp
  1013e8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  1013ec:	e24cb004 	sub	fp, ip, #4	; 0x4
  1013f0:	e24dd008 	sub	sp, sp, #8	; 0x8
  1013f4:	e50b0010 	str	r0, [fp, #-16]
  1013f8:	e50b1014 	str	r1, [fp, #-20]
	pPMC->PMC_PCER = periphIds;
  1013fc:	e51b2010 	ldr	r2, [fp, #-16]
  101400:	e51b3014 	ldr	r3, [fp, #-20]
  101404:	e5823010 	str	r3, [r2, #16]
}
  101408:	e24bd00c 	sub	sp, fp, #12	; 0xc
  10140c:	e89da800 	ldmia	sp, {fp, sp, pc}

00101410 <AT91F_SPI_Reset>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PMC_DisablePeriphClock
//* \brief Disable peripheral clock
//*----------------------------------------------------------------------------
static __inline void AT91F_PMC_DisablePeriphClock (
	AT91PS_PMC pPMC, // \arg pointer to PMC controller
	unsigned int periphIds)  // \arg IDs of peripherals to enable
{
	pPMC->PMC_PCDR = periphIds;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_PMC_GetPeriphClock
//* \brief Get peripheral clock status
//*----------------------------------------------------------------------------
static __inline unsigned int AT91F_PMC_GetPeriphClock (
	AT91PS_PMC pPMC) // \arg pointer to PMC controller
{
	return pPMC->PMC_PCSR;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_CKGR_CfgMainOscillatorReg
//* \brief Cfg the main oscillator
//*----------------------------------------------------------------------------
static __inline void AT91F_CKGR_CfgMainOscillatorReg (
	AT91PS_CKGR pCKGR, // \arg pointer to CKGR controller
	unsigned int mode)
{
	pCKGR->CKGR_MOR = mode;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_CKGR_GetMainOscillatorReg
//* \brief Cfg the main oscillator
//*----------------------------------------------------------------------------
static __inline unsigned int AT91F_CKGR_GetMainOscillatorReg (
	AT91PS_CKGR pCKGR) // \arg pointer to CKGR controller
{
	return pCKGR->CKGR_MOR;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_CKGR_EnableMainOscillator
//* \brief Enable the main oscillator
//*----------------------------------------------------------------------------
static __inline void AT91F_CKGR_EnableMainOscillator(
	AT91PS_CKGR pCKGR) // \arg pointer to CKGR controller
{
	pCKGR->CKGR_MOR |= AT91C_CKGR_MOSCEN;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_CKGR_DisableMainOscillator
//* \brief Disable the main oscillator
//*----------------------------------------------------------------------------
static __inline void AT91F_CKGR_DisableMainOscillator (
	AT91PS_CKGR pCKGR) // \arg pointer to CKGR controller
{
	pCKGR->CKGR_MOR &= ~AT91C_CKGR_MOSCEN;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_CKGR_CfgMainOscStartUpTime
//* \brief Cfg MOR Register according to the main osc startup time
//*----------------------------------------------------------------------------
static __inline void AT91F_CKGR_CfgMainOscStartUpTime (
	AT91PS_CKGR pCKGR, // \arg pointer to CKGR controller
	unsigned int startup_time,  // \arg main osc startup time in microsecond (us)
	unsigned int slowClock)  // \arg slowClock in Hz
{
	pCKGR->CKGR_MOR &= ~AT91C_CKGR_OSCOUNT;
	pCKGR->CKGR_MOR |= ((slowClock * startup_time)/(8*1000000)) << 8;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_CKGR_GetMainClockFreqReg
//* \brief Cfg the main oscillator
//*----------------------------------------------------------------------------
static __inline unsigned int AT91F_CKGR_GetMainClockFreqReg (
	AT91PS_CKGR pCKGR) // \arg pointer to CKGR controller
{
	return pCKGR->CKGR_MCFR;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_CKGR_GetMainClock
//* \brief Return Main clock in Hz
//*----------------------------------------------------------------------------
static __inline unsigned int AT91F_CKGR_GetMainClock (
	AT91PS_CKGR pCKGR, // \arg pointer to CKGR controller
	unsigned int slowClock)  // \arg slowClock in Hz
{
	return ((pCKGR->CKGR_MCFR  & AT91C_CKGR_MAINF) * slowClock) >> 4;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_PMC_CfgMCKReg
//* \brief Cfg Master Clock Register
//*----------------------------------------------------------------------------
static __inline void AT91F_PMC_CfgMCKReg (
	AT91PS_PMC pPMC, // \arg pointer to PMC controller
	unsigned int mode)
{
	pPMC->PMC_MCKR = mode;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_PMC_GetMCKReg
//* \brief Return Master Clock Register
//*----------------------------------------------------------------------------
static __inline unsigned int AT91F_PMC_GetMCKReg(
	AT91PS_PMC pPMC) // \arg pointer to PMC controller
{
	return pPMC->PMC_MCKR;
}

//*------------------------------------------------------------------------------
//* \fn    AT91F_PMC_GetMasterClock
//* \brief Return master clock in Hz which correponds to processor clock for ARM7
//*------------------------------------------------------------------------------
static __inline unsigned int AT91F_PMC_GetMasterClock (
	AT91PS_PMC pPMC, // \arg pointer to PMC controller
	AT91PS_CKGR pCKGR, // \arg pointer to CKGR controller
	unsigned int slowClock)  // \arg slowClock in Hz
{
	unsigned int reg = pPMC->PMC_MCKR;
	unsigned int prescaler = (1 << ((reg & AT91C_PMC_PRES) >> 2));
	unsigned int pllDivider, pllMultiplier;

	switch (reg & AT91C_PMC_CSS) {
		case AT91C_PMC_CSS_SLOW_CLK: // Slow clock selected
			return slowClock / prescaler;
		case AT91C_PMC_CSS_MAIN_CLK: // Main clock is selected
			return AT91F_CKGR_GetMainClock(pCKGR, slowClock) / prescaler;
		case AT91C_PMC_CSS_PLL_CLK: // PLLB clock is selected
			reg = pCKGR->CKGR_PLLR;
			pllDivider    = (reg  & AT91C_CKGR_DIV);
			pllMultiplier = ((reg  & AT91C_CKGR_MUL) >> 16) + 1;
			return AT91F_CKGR_GetMainClock(pCKGR, slowClock) / pllDivider * pllMultiplier / prescaler;
	}
	return 0;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_PMC_EnablePCK
//* \brief Enable peripheral clock
//*----------------------------------------------------------------------------
static __inline void AT91F_PMC_EnablePCK (
	AT91PS_PMC pPMC, // \arg pointer to PMC controller
	unsigned int pck,  // \arg Peripheral clock identifier 0 .. 7
	unsigned int mode)
{
	pPMC->PMC_PCKR[pck] = mode;
	pPMC->PMC_SCER = (1 << pck) << 8;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_PMC_DisablePCK
//* \brief Enable peripheral clock
//*----------------------------------------------------------------------------
static __inline void AT91F_PMC_DisablePCK (
	AT91PS_PMC pPMC, // \arg pointer to PMC controller
	unsigned int pck)  // \arg Peripheral clock identifier 0 .. 7
{
	pPMC->PMC_SCDR = (1 << pck) << 8;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_PMC_EnableIt
//* \brief Enable PMC interrupt
//*----------------------------------------------------------------------------
static __inline void AT91F_PMC_EnableIt (
	AT91PS_PMC pPMC,     // pointer to a PMC controller
	unsigned int flag)   // IT to be enabled
{
	//* Write to the IER register
	pPMC->PMC_IER = flag;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_PMC_DisableIt
//* \brief Disable PMC interrupt
//*----------------------------------------------------------------------------
static __inline void AT91F_PMC_DisableIt (
	AT91PS_PMC pPMC, // pointer to a PMC controller
	unsigned int flag) // IT to be disabled
{
	//* Write to the IDR register
	pPMC->PMC_IDR = flag;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_PMC_GetStatus
//* \brief Return PMC Interrupt Status
//*----------------------------------------------------------------------------
static __inline unsigned int AT91F_PMC_GetStatus( // \return PMC Interrupt Status
	AT91PS_PMC pPMC) // pointer to a PMC controller
{
	return pPMC->PMC_SR;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_PMC_GetInterruptMaskStatus
//* \brief Return PMC Interrupt Mask Status
//*----------------------------------------------------------------------------
static __inline unsigned int AT91F_PMC_GetInterruptMaskStatus( // \return PMC Interrupt Mask Status
	AT91PS_PMC pPMC) // pointer to a PMC controller
{
	return pPMC->PMC_IMR;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_PMC_IsInterruptMasked
//* \brief Test if PMC Interrupt is Masked
//*----------------------------------------------------------------------------
static __inline unsigned int AT91F_PMC_IsInterruptMasked(
        AT91PS_PMC pPMC,   // \arg  pointer to a PMC controller
        unsigned int flag) // \arg  flag to be tested
{
	return (AT91F_PMC_GetInterruptMaskStatus(pPMC) & flag);
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_PMC_IsStatusSet
//* \brief Test if PMC Status is Set
//*----------------------------------------------------------------------------
static __inline unsigned int AT91F_PMC_IsStatusSet(
        AT91PS_PMC pPMC,   // \arg  pointer to a PMC controller
        unsigned int flag) // \arg  flag to be tested
{
	return (AT91F_PMC_GetStatus(pPMC) & flag);
}

// ----------------------------------------------------------------------------
//  \fn    AT91F_CKGR_CfgPLLReg
//  \brief Cfg the PLL Register
// ----------------------------------------------------------------------------
static __inline void AT91F_CKGR_CfgPLLReg (
	AT91PS_CKGR pCKGR, // \arg pointer to CKGR controller
	unsigned int mode)
{
	pCKGR->CKGR_PLLR = mode;
}

// ----------------------------------------------------------------------------
//  \fn    AT91F_CKGR_GetPLLReg
//  \brief Get the PLL Register
// ----------------------------------------------------------------------------
static __inline unsigned int AT91F_CKGR_GetPLLReg (
	AT91PS_CKGR pCKGR) // \arg pointer to CKGR controller
{
	return pCKGR->CKGR_PLLR;
}



/* *****************************************************************************
                SOFTWARE API FOR RSTC
   ***************************************************************************** */
//*----------------------------------------------------------------------------
//* \fn    AT91F_RSTSoftReset
//* \brief Start Software Reset
//*----------------------------------------------------------------------------
static __inline void AT91F_RSTSoftReset(
        AT91PS_RSTC pRSTC,
        unsigned int reset)
{
	pRSTC->RSTC_RCR = (0xA5000000 | reset);
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_RSTSetMode
//* \brief Set Reset Mode
//*----------------------------------------------------------------------------
static __inline void AT91F_RSTSetMode(
        AT91PS_RSTC pRSTC,
        unsigned int mode)
{
	pRSTC->RSTC_RMR = (0xA5000000 | mode);
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_RSTGetMode
//* \brief Get Reset Mode
//*----------------------------------------------------------------------------
static __inline unsigned int AT91F_RSTGetMode(
        AT91PS_RSTC pRSTC)
{
	return (pRSTC->RSTC_RMR);
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_RSTGetStatus
//* \brief Get Reset Status
//*----------------------------------------------------------------------------
static __inline unsigned int AT91F_RSTGetStatus(
        AT91PS_RSTC pRSTC)
{
	return (pRSTC->RSTC_RSR);
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_RSTIsSoftRstActive
//* \brief Return !=0 if software reset is still not completed
//*----------------------------------------------------------------------------
static __inline unsigned int AT91F_RSTIsSoftRstActive(
        AT91PS_RSTC pRSTC)
{
	return ((pRSTC->RSTC_RSR) & AT91C_RSTC_SRCMP);
}
/* *****************************************************************************
                SOFTWARE API FOR RTTC
   ***************************************************************************** */
//*--------------------------------------------------------------------------------------
//* \fn     AT91F_SetRTT_TimeBase()
//* \brief  Set the RTT prescaler according to the TimeBase in ms
//*--------------------------------------------------------------------------------------
static __inline unsigned int AT91F_RTTSetTimeBase(
        AT91PS_RTTC pRTTC, 
        unsigned int ms)
{
	if (ms > 2000)
		return 1;   // AT91C_TIME_OUT_OF_RANGE
	pRTTC->RTTC_RTMR &= ~0xFFFF;	
	pRTTC->RTTC_RTMR |= (((ms << 15) /1000) & 0xFFFF);	
	return 0;
}

//*--------------------------------------------------------------------------------------
//* \fn     AT91F_RTTSetPrescaler()
//* \brief  Set the new prescaler value
//*--------------------------------------------------------------------------------------
static __inline unsigned int AT91F_RTTSetPrescaler(
        AT91PS_RTTC pRTTC, 
        unsigned int rtpres)
{
	pRTTC->RTTC_RTMR &= ~0xFFFF;	
	pRTTC->RTTC_RTMR |= (rtpres & 0xFFFF);	
	return (pRTTC->RTTC_RTMR);
}

//*--------------------------------------------------------------------------------------
//* \fn     AT91F_RTTRestart()
//* \brief  Restart the RTT prescaler
//*--------------------------------------------------------------------------------------
static __inline void AT91F_RTTRestart(
        AT91PS_RTTC pRTTC)
{
	pRTTC->RTTC_RTMR |= AT91C_RTTC_RTTRST;	
}


//*--------------------------------------------------------------------------------------
//* \fn     AT91F_RTT_SetAlarmINT()
//* \brief  Enable RTT Alarm Interrupt
//*--------------------------------------------------------------------------------------
static __inline void AT91F_RTTSetAlarmINT(
        AT91PS_RTTC pRTTC)
{
	pRTTC->RTTC_RTMR |= AT91C_RTTC_ALMIEN;
}

//*--------------------------------------------------------------------------------------
//* \fn     AT91F_RTT_ClearAlarmINT()
//* \brief  Disable RTT Alarm Interrupt
//*--------------------------------------------------------------------------------------
static __inline void AT91F_RTTClearAlarmINT(
        AT91PS_RTTC pRTTC)
{
	pRTTC->RTTC_RTMR &= ~AT91C_RTTC_ALMIEN;
}

//*--------------------------------------------------------------------------------------
//* \fn     AT91F_RTT_SetRttIncINT()
//* \brief  Enable RTT INC Interrupt
//*--------------------------------------------------------------------------------------
static __inline void AT91F_RTTSetRttIncINT(
        AT91PS_RTTC pRTTC)
{
	pRTTC->RTTC_RTMR |= AT91C_RTTC_RTTINCIEN;
}

//*--------------------------------------------------------------------------------------
//* \fn     AT91F_RTT_ClearRttIncINT()
//* \brief  Disable RTT INC Interrupt
//*--------------------------------------------------------------------------------------
static __inline void AT91F_RTTClearRttIncINT(
        AT91PS_RTTC pRTTC)
{
	pRTTC->RTTC_RTMR &= ~AT91C_RTTC_RTTINCIEN;
}

//*--------------------------------------------------------------------------------------
//* \fn     AT91F_RTT_SetAlarmValue()
//* \brief  Set RTT Alarm Value
//*--------------------------------------------------------------------------------------
static __inline void AT91F_RTTSetAlarmValue(
        AT91PS_RTTC pRTTC, unsigned int alarm)
{
	pRTTC->RTTC_RTAR = alarm;
}

//*--------------------------------------------------------------------------------------
//* \fn     AT91F_RTT_GetAlarmValue()
//* \brief  Get RTT Alarm Value
//*--------------------------------------------------------------------------------------
static __inline unsigned int AT91F_RTTGetAlarmValue(
        AT91PS_RTTC pRTTC)
{
	return(pRTTC->RTTC_RTAR);
}

//*--------------------------------------------------------------------------------------
//* \fn     AT91F_RTTGetStatus()
//* \brief  Read the RTT status
//*--------------------------------------------------------------------------------------
static __inline unsigned int AT91F_RTTGetStatus(
        AT91PS_RTTC pRTTC)
{
	return(pRTTC->RTTC_RTSR);
}

//*--------------------------------------------------------------------------------------
//* \fn     AT91F_RTT_ReadValue()
//* \brief  Read the RTT value
//*--------------------------------------------------------------------------------------
static __inline unsigned int AT91F_RTTReadValue(
        AT91PS_RTTC pRTTC)
{
        register volatile unsigned int val1,val2;
	do
	{
		val1 = pRTTC->RTTC_RTVR;
		val2 = pRTTC->RTTC_RTVR;
	}	
	while(val1 != val2);
	return(val1);
}
/* *****************************************************************************
                SOFTWARE API FOR PITC
   ***************************************************************************** */
//*----------------------------------------------------------------------------
//* \fn    AT91F_PITInit
//* \brief System timer init : period in ï¿½second, system clock freq in MHz
//*----------------------------------------------------------------------------
static __inline void AT91F_PITInit(
        AT91PS_PITC pPITC,
        unsigned int period,
        unsigned int pit_frequency)
{
	pPITC->PITC_PIMR = period? (period * pit_frequency + 8) >> 4 : 0; // +8 to avoid %10 and /10
	pPITC->PITC_PIMR |= AT91C_PITC_PITEN;	 
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_PITSetPIV
//* \brief Set the PIT Periodic Interval Value 
//*----------------------------------------------------------------------------
static __inline void AT91F_PITSetPIV(
        AT91PS_PITC pPITC,
        unsigned int piv)
{
	pPITC->PITC_PIMR = piv | (pPITC->PITC_PIMR & (AT91C_PITC_PITEN | AT91C_PITC_PITIEN));
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_PITEnableInt
//* \brief Enable PIT periodic interrupt
//*----------------------------------------------------------------------------
static __inline void AT91F_PITEnableInt(
        AT91PS_PITC pPITC)
{
	pPITC->PITC_PIMR |= AT91C_PITC_PITIEN;	 
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_PITDisableInt
//* \brief Disable PIT periodic interrupt
//*----------------------------------------------------------------------------
static __inline void AT91F_PITDisableInt(
        AT91PS_PITC pPITC)
{
	pPITC->PITC_PIMR &= ~AT91C_PITC_PITIEN;	 
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_PITGetMode
//* \brief Read PIT mode register
//*----------------------------------------------------------------------------
static __inline unsigned int AT91F_PITGetMode(
        AT91PS_PITC pPITC)
{
	return(pPITC->PITC_PIMR);
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_PITGetStatus
//* \brief Read PIT status register
//*----------------------------------------------------------------------------
static __inline unsigned int AT91F_PITGetStatus(
        AT91PS_PITC pPITC)
{
	return(pPITC->PITC_PISR);
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_PITGetPIIR
//* \brief Read PIT CPIV and PICNT without ressetting the counters
//*----------------------------------------------------------------------------
static __inline unsigned int AT91F_PITGetPIIR(
        AT91PS_PITC pPITC)
{
	return(pPITC->PITC_PIIR);
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_PITGetPIVR
//* \brief Read System timer CPIV and PICNT without ressetting the counters
//*----------------------------------------------------------------------------
static __inline unsigned int AT91F_PITGetPIVR(
        AT91PS_PITC pPITC)
{
	return(pPITC->PITC_PIVR);
}
/* *****************************************************************************
                SOFTWARE API FOR WDTC
   ***************************************************************************** */
//*----------------------------------------------------------------------------
//* \fn    AT91F_WDTSetMode
//* \brief Set Watchdog Mode Register
//*----------------------------------------------------------------------------
static __inline void AT91F_WDTSetMode(
        AT91PS_WDTC pWDTC,
        unsigned int Mode)
{
	pWDTC->WDTC_WDMR = Mode;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_WDTRestart
//* \brief Restart Watchdog
//*----------------------------------------------------------------------------
static __inline void AT91F_WDTRestart(
        AT91PS_WDTC pWDTC)
{
	pWDTC->WDTC_WDCR = 0xA5000001;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_WDTSGettatus
//* \brief Get Watchdog Status
//*----------------------------------------------------------------------------
static __inline unsigned int AT91F_WDTSGettatus(
        AT91PS_WDTC pWDTC)
{
	return(pWDTC->WDTC_WDSR & 0x3);
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_WDTGetPeriod
//* \brief Translate ms into Watchdog Compatible value
//*----------------------------------------------------------------------------
static __inline unsigned int AT91F_WDTGetPeriod(unsigned int ms)
{
	if ((ms < 4) || (ms > 16000))
		return 0;
	return((ms << 8) / 1000);
}
/* *****************************************************************************
                SOFTWARE API FOR VREG
   ***************************************************************************** */
//*----------------------------------------------------------------------------
//* \fn    AT91F_VREG_Enable_LowPowerMode
//* \brief Enable VREG Low Power Mode
//*----------------------------------------------------------------------------
static __inline void AT91F_VREG_Enable_LowPowerMode(
        AT91PS_VREG pVREG)
{
	pVREG->VREG_MR |= AT91C_VREG_PSTDBY;	 
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_VREG_Disable_LowPowerMode
//* \brief Disable VREG Low Power Mode
//*----------------------------------------------------------------------------
static __inline void AT91F_VREG_Disable_LowPowerMode(
        AT91PS_VREG pVREG)
{
	pVREG->VREG_MR &= ~AT91C_VREG_PSTDBY;	 
}/* *****************************************************************************
                SOFTWARE API FOR MC
   ***************************************************************************** */

#define AT91C_MC_CORRECT_KEY  ((unsigned int) 0x5A << 24) // (MC) Correct Protect Key

//*----------------------------------------------------------------------------
//* \fn    AT91F_MC_Remap
//* \brief Make Remap
//*----------------------------------------------------------------------------
static __inline void AT91F_MC_Remap (void)     //  
{
    AT91PS_MC pMC = (AT91PS_MC) AT91C_BASE_MC;
    
    pMC->MC_RCR = AT91C_MC_RCB;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_MC_EFC_CfgModeReg
//* \brief Configure the EFC Mode Register of the MC controller
//*----------------------------------------------------------------------------
static __inline void AT91F_MC_EFC_CfgModeReg (
	AT91PS_MC pMC, // pointer to a MC controller
	unsigned int mode)        // mode register 
{
	// Write to the FMR register
	pMC->MC_FMR = mode;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_MC_EFC_GetModeReg
//* \brief Return MC EFC Mode Regsiter
//*----------------------------------------------------------------------------
static __inline unsigned int AT91F_MC_EFC_GetModeReg(
	AT91PS_MC pMC) // pointer to a MC controller
{
	return pMC->MC_FMR;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_MC_EFC_ComputeFMCN
//* \brief Return MC EFC Mode Regsiter
//*----------------------------------------------------------------------------
static __inline unsigned int AT91F_MC_EFC_ComputeFMCN(
	int master_clock) // master clock in Hz
{
	return (master_clock/1000000 +2);
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_MC_EFC_PerformCmd
//* \brief Perform EFC Command
//*----------------------------------------------------------------------------
static __inline void AT91F_MC_EFC_PerformCmd (
	AT91PS_MC pMC, // pointer to a MC controller
    unsigned int transfer_cmd)
{
	pMC->MC_FCR = transfer_cmd;	
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_MC_EFC_GetStatus
//* \brief Return MC EFC Status
//*----------------------------------------------------------------------------
static __inline unsigned int AT91F_MC_EFC_GetStatus(
	AT91PS_MC pMC) // pointer to a MC controller
{
	return pMC->MC_FSR;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_MC_EFC_IsInterruptMasked
//* \brief Test if EFC MC Interrupt is Masked 
//*----------------------------------------------------------------------------
static __inline unsigned int AT91F_MC_EFC_IsInterruptMasked(
        AT91PS_MC pMC,   // \arg  pointer to a MC controller
        unsigned int flag) // \arg  flag to be tested
{
	return (AT91F_MC_EFC_GetModeReg(pMC) & flag);
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_MC_EFC_IsInterruptSet
//* \brief Test if EFC MC Interrupt is Set
//*----------------------------------------------------------------------------
static __inline unsigned int AT91F_MC_EFC_IsInterruptSet(
        AT91PS_MC pMC,   // \arg  pointer to a MC controller
        unsigned int flag) // \arg  flag to be tested
{
	return (AT91F_MC_EFC_GetStatus(pMC) & flag);
}

/* *****************************************************************************
                SOFTWARE API FOR SPI
   ***************************************************************************** */
//*----------------------------------------------------------------------------
//* \fn    AT91F_SPI_CfgCs
//* \brief Configure SPI chip select register
//*----------------------------------------------------------------------------
static __inline void AT91F_SPI_CfgCs (
	AT91PS_SPI pSPI,     // pointer to a SPI controller
	int cs,     // SPI cs number (0 to 3)
 	int val)   //  chip select register
{
	//* Write to the CSR register
	*(pSPI->SPI_CSR + cs) = val;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_SPI_EnableIt
//* \brief Enable SPI interrupt
//*----------------------------------------------------------------------------
static __inline void AT91F_SPI_EnableIt (
	AT91PS_SPI pSPI,     // pointer to a SPI controller
	unsigned int flag)   // IT to be enabled
{
	//* Write to the IER register
	pSPI->SPI_IER = flag;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_SPI_DisableIt
//* \brief Disable SPI interrupt
//*----------------------------------------------------------------------------
static __inline void AT91F_SPI_DisableIt (
	AT91PS_SPI pSPI, // pointer to a SPI controller
	unsigned int flag) // IT to be disabled
{
	//* Write to the IDR register
	pSPI->SPI_IDR = flag;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_SPI_Reset
//* \brief Reset the SPI controller
//*----------------------------------------------------------------------------
static __inline void AT91F_SPI_Reset (
	AT91PS_SPI pSPI // pointer to a SPI controller
	)
{
  101410:	e1a0c00d 	mov	ip, sp
  101414:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  101418:	e24cb004 	sub	fp, ip, #4	; 0x4
  10141c:	e24dd004 	sub	sp, sp, #4	; 0x4
  101420:	e50b0010 	str	r0, [fp, #-16]
	//* Write to the CR register
	pSPI->SPI_CR = AT91C_SPI_SWRST;
  101424:	e51b2010 	ldr	r2, [fp, #-16]
  101428:	e3a03080 	mov	r3, #128	; 0x80
  10142c:	e5823000 	str	r3, [r2]
}
  101430:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

00101434 <AT91F_SPI_Enable>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SPI_Enable
//* \brief Enable the SPI controller
//*----------------------------------------------------------------------------
static __inline void AT91F_SPI_Enable (
	AT91PS_SPI pSPI // pointer to a SPI controller
	)
{
  101434:	e1a0c00d 	mov	ip, sp
  101438:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  10143c:	e24cb004 	sub	fp, ip, #4	; 0x4
  101440:	e24dd004 	sub	sp, sp, #4	; 0x4
  101444:	e50b0010 	str	r0, [fp, #-16]
	//* Write to the CR register
	pSPI->SPI_CR = AT91C_SPI_SPIEN;
  101448:	e51b2010 	ldr	r2, [fp, #-16]
  10144c:	e3a03001 	mov	r3, #1	; 0x1
  101450:	e5823000 	str	r3, [r2]
}
  101454:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

00101458 <AT91F_SPI_CfgMode>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SPI_Disable
//* \brief Disable the SPI controller
//*----------------------------------------------------------------------------
static __inline void AT91F_SPI_Disable (
	AT91PS_SPI pSPI // pointer to a SPI controller
	)
{
	//* Write to the CR register
	pSPI->SPI_CR = AT91C_SPI_SPIDIS;
}

//*----------------------------------------------------------------------------
//* \fn    AT91F_SPI_CfgMode
//* \brief Enable the SPI controller
//*----------------------------------------------------------------------------
static __inline void AT91F_SPI_CfgMode (
	AT91PS_SPI pSPI, // pointer to a SPI controller
	int mode)        // mode register 
{
  101458:	e1a0c00d 	mov	ip, sp
  10145c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  101460:	e24cb004 	sub	fp, ip, #4	; 0x4
  101464:	e24dd008 	sub	sp, sp, #8	; 0x8
  101468:	e50b0010 	str	r0, [fp, #-16]
  10146c:	e50b1014 	str	r1, [fp, #-20]
	//* Write to the MR register
	pSPI->SPI_MR = mode;
  101470:	e51b2014 	ldr	r2, [fp, #-20]
  101474:	e51b3010 	ldr	r3, [fp, #-16]
  101478:	e5832004 	str	r2, [r3, #4]
}
  10147c:	e24bd00c 	sub	sp, fp, #12	; 0xc
  101480:	e89da800 	ldmia	sp, {fp, sp, pc}

00101484 <AT91F_SPI_CfgCs>:
  101484:	e1a0c00d 	mov	ip, sp
  101488:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  10148c:	e24cb004 	sub	fp, ip, #4	; 0x4
  101490:	e24dd00c 	sub	sp, sp, #12	; 0xc
  101494:	e50b0010 	str	r0, [fp, #-16]
  101498:	e50b1014 	str	r1, [fp, #-20]
  10149c:	e50b2018 	str	r2, [fp, #-24]
  1014a0:	e51b3010 	ldr	r3, [fp, #-16]
  1014a4:	e2832030 	add	r2, r3, #48	; 0x30
  1014a8:	e51b3014 	ldr	r3, [fp, #-20]
  1014ac:	e1a03103 	mov	r3, r3, lsl #2
  1014b0:	e0822003 	add	r2, r2, r3
  1014b4:	e51b3018 	ldr	r3, [fp, #-24]
  1014b8:	e5823000 	str	r3, [r2]
  1014bc:	e24bd00c 	sub	sp, fp, #12	; 0xc
  1014c0:	e89da800 	ldmia	sp, {fp, sp, pc}

001014c4 <vFdvPWM_init>:
	
}*/

void vFdvPWM_init( void )
{
  1014c4:	e1a0c00d 	mov	ip, sp
  1014c8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  1014cc:	e24cb004 	sub	fp, ip, #4	; 0x4
	// disable PIO from PWM0
	//AT91F_PIO_CfgPeriph(AT91C_BASE_PIOA,AT91C_PA23_PWM0,0);
	//AT91F_PWMC_CH0_CfgPIO();
	
	AT91C_BASE_PIOA->PIO_PDR=AT91C_PA23_PWM0;
  1014d0:	e3a0320a 	mov	r3, #-1610612736	; 0xa0000000
  1014d4:	e1a039c3 	mov	r3, r3, asr #19
  1014d8:	e3a02502 	mov	r2, #8388608	; 0x800000
  1014dc:	e5832004 	str	r2, [r3, #4]
	AT91C_BASE_PIOA->PIO_BSR=AT91C_PA23_PWM0;
  1014e0:	e3a0320a 	mov	r3, #-1610612736	; 0xa0000000
  1014e4:	e1a039c3 	mov	r3, r3, asr #19
  1014e8:	e3a02502 	mov	r2, #8388608	; 0x800000
  1014ec:	e5832074 	str	r2, [r3, #116]
	// enable peripheral clock for PWM( PID Bit 10 )
	AT91F_PWMC_CfgPMC();
  1014f0:	eb00001e 	bl	101570 <AT91F_PWMC_CfgPMC>
	// Initially they're stopped
	AT91C_BASE_PWMC->PWMC_DIS =  AT91C_PWMC_CHID0;
  1014f4:	e3a03326 	mov	r3, #-1744830464	; 0x98000000
  1014f8:	e1a036c3 	mov	r3, r3, asr #13
  1014fc:	e3a02001 	mov	r2, #1	; 0x1
  101500:	e5832008 	str	r2, [r3, #8]
	// Set the Clock A divider
	AT91C_BASE_PWMC->PWMC_MR = (( 4 << 8 ) | 0x08 );  // MCK selection or'ed with Divider
  101504:	e3a02326 	mov	r2, #-1744830464	; 0x98000000
  101508:	e1a026c2 	mov	r2, r2, asr #13
  10150c:	e3a03b01 	mov	r3, #1024	; 0x400
  101510:	e2833008 	add	r3, r3, #8	; 0x8
  101514:	e5823000 	str	r3, [r2]
	//AT91C_BASE_PWMC->PWMC_MR = 0; //don't use clock A & B
	  // Set the Clock
	AT91C_BASE_PWMC->PWMC_CH[ 0 ].PWMC_CMR =AT91C_PWMC_CPRE_MCKA |AT91C_PWMC_CPOL;     //Divider Clock A | Channel Polarity Invert
  101518:	e3a02326 	mov	r2, #-1744830464	; 0x98000000
  10151c:	e1a026c2 	mov	r2, r2, asr #13
  101520:	e3a03f82 	mov	r3, #520	; 0x208
  101524:	e2833003 	add	r3, r3, #3	; 0x3
  101528:	e5823200 	str	r3, [r2, #512]
	//AT91C_BASE_PWMC->PWMC_CH[ 0 ].PWMC_CMR = 0xa;     //Use MCK/1024
	//AT91C_BASE_PWMC->PWMC_CH[ 0 ].PWMC_CMR =0x8|AT91C_PWMC_CPOL;     //Divider Clock A | Channel Polarity Invert
    // Set the Period register (sample size bit fied )
	AT91C_BASE_PWMC->PWMC_CH[ 0 ].PWMC_CPRDR = 1024; //
  10152c:	e3a03326 	mov	r3, #-1744830464	; 0x98000000
  101530:	e1a036c3 	mov	r3, r3, asr #13
  101534:	e3a02b01 	mov	r2, #1024	; 0x400
  101538:	e5832208 	str	r2, [r3, #520]
	// Set the duty cycle register (output value)
	AT91C_BASE_PWMC->PWMC_CH[ 0 ].PWMC_CDTYR = 512; //50%
  10153c:	e3a03326 	mov	r3, #-1744830464	; 0x98000000
  101540:	e1a036c3 	mov	r3, r3, asr #13
  101544:	e3a02c02 	mov	r2, #512	; 0x200
  101548:	e5832204 	str	r2, [r3, #516]
	// Initialise the Update register write only
	AT91C_BASE_PWMC->PWMC_CH[ 0 ].PWMC_CUPDR = 512 ;
  10154c:	e3a03326 	mov	r3, #-1744830464	; 0x98000000
  101550:	e1a036c3 	mov	r3, r3, asr #13
  101554:	e3a02c02 	mov	r2, #512	; 0x200
  101558:	e5832210 	str	r2, [r3, #528]
	//Enable PWM0
	AT91C_BASE_PWMC->PWMC_ENA =  AT91C_PWMC_CHID0;
  10155c:	e3a03326 	mov	r3, #-1744830464	; 0x98000000
  101560:	e1a036c3 	mov	r3, r3, asr #13
  101564:	e3a02001 	mov	r2, #1	; 0x1
  101568:	e5832004 	str	r2, [r3, #4]

}
  10156c:	e89da800 	ldmia	sp, {fp, sp, pc}

00101570 <AT91F_PWMC_CfgPMC>:
//* \fn    AT91F_PWMC_CfgPMC
//* \brief Enable Peripheral clock in PMC for  PWMC
//*----------------------------------------------------------------------------
static __inline void AT91F_PWMC_CfgPMC (void)
{
  101570:	e1a0c00d 	mov	ip, sp
  101574:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  101578:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
  10157c:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
  101580:	e1a00ac0 	mov	r0, r0, asr #21
  101584:	e3a01b01 	mov	r1, #1024	; 0x400
  101588:	eb000000 	bl	101590 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_PWMC));
}
  10158c:	e89da800 	ldmia	sp, {fp, sp, pc}

00101590 <AT91F_PMC_EnablePeriphClock>:
  101590:	e1a0c00d 	mov	ip, sp
  101594:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  101598:	e24cb004 	sub	fp, ip, #4	; 0x4
  10159c:	e24dd008 	sub	sp, sp, #8	; 0x8
  1015a0:	e50b0010 	str	r0, [fp, #-16]
  1015a4:	e50b1014 	str	r1, [fp, #-20]
  1015a8:	e51b2010 	ldr	r2, [fp, #-16]
  1015ac:	e51b3014 	ldr	r3, [fp, #-20]
  1015b0:	e5823010 	str	r3, [r2, #16]
  1015b4:	e24bd00c 	sub	sp, fp, #12	; 0xc
  1015b8:	e89da800 	ldmia	sp, {fp, sp, pc}

001015bc <vFdvManager_Init>:
#include "dvManager.h"
void vFdvUart0_init (void);
void vFdvManager_Init( void )
{
  1015bc:	e1a0c00d 	mov	ip, sp
  1015c0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  1015c4:	e24cb004 	sub	fp, ip, #4	; 0x4
	
	vFdvTimer_init ();                            /* Initialize Timer */
  1015c8:	ebfffebd 	bl	1010c4 <vFdvTimer_init>
	vFdvExtInt_init();                            /* Initialize External Interrupt */
  1015cc:	eb000001 	bl	1015d8 <vFdvExtInt_init>
	vFdvUart0_init();                             /* Initialize Serial Interface */
  1015d0:	ebfffdcd 	bl	100d0c <vFdvUart0_init>
	
}
  1015d4:	e89da800 	ldmia	sp, {fp, sp, pc}

001015d8 <vFdvExtInt_init>:
  ISR_RESTORE();
}


void vFdvExtInt_init(void) {                   /* Setup IRQ 0 Interrupt */
  1015d8:	e1a0c00d 	mov	ip, sp
  1015dc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
  1015e0:	e24cb004 	sub	fp, ip, #4	; 0x4
  1015e4:	e24dd004 	sub	sp, sp, #4	; 0x4
  volatile AT91S_AIC * pAIC = AT91C_BASE_AIC;
  1015e8:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
  1015ec:	e1a039c3 	mov	r3, r3, asr #19
  1015f0:	e50b3010 	str	r3, [fp, #-16]

  /* Setup IRQ0 Interrupt Mode and Vector with Priority 0 and Enable it */
  // mt: pAIC->AIC_SMR[AT91C_ID_IRQ0] = AT91C_AIC_SRCTYPE_INT_EDGE_TRIGGERED | 0;
  pAIC->AIC_SMR[AT91C_ID_IRQ0] = AT91C_AIC_SRCTYPE_INT_POSITIVE_EDGE | 0;
  1015f4:	e51b2010 	ldr	r2, [fp, #-16]
  1015f8:	e3a03020 	mov	r3, #32	; 0x20
  1015fc:	e5823078 	str	r3, [r2, #120]
 
  pAIC->AIC_SVR[AT91C_ID_IRQ0] = (unsigned long) irq0_int;
  101600:	e59f3018 	ldr	r3, [pc, #24]	; 101620 <.text+0x1620>
  101604:	e1a02003 	mov	r2, r3
  101608:	e51b3010 	ldr	r3, [fp, #-16]
  10160c:	e58320f8 	str	r2, [r3, #248]
  pAIC->AIC_IECR = (1 << AT91C_ID_IRQ0);
  101610:	e51b2010 	ldr	r2, [fp, #-16]
  101614:	e3a03101 	mov	r3, #1073741824	; 0x40000000
  101618:	e5823120 	str	r3, [r2, #288]
}
  10161c:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
  101620:	002008a8 	eoreq	r0, r0, r8, lsr #17

00101624 <vFappTest_init>:

void vFappTest_init( void )
{

}
  101624:	e12fff1e 	bx	lr

00101628 <vFappTest>:

void vFappTest( void )
{

}
  101628:	e12fff1e 	bx	lr

0010162c <vFPrintString>:
  10162c:	e92d4010 	stmdb	sp!, {r4, lr}
  101630:	e1a04000 	mov	r4, r0
  101634:	eb0003cb 	bl	102568 <strlen>
  101638:	e1a01000 	mov	r1, r0
  10163c:	e1a00004 	mov	r0, r4
  101640:	ebfffad3 	bl	100194 <cFlibUart_SendBuff>
  101644:	e8bd8010 	ldmia	sp!, {r4, pc}

00101648 <vFappManager_Main>:
	//vFappIpStack_Init();
}

void vFappManager_Main( void)
{
  101648:	e52de004 	str	lr, [sp, #-4]!
	vFappTest();
  10164c:	ebfffff5 	bl	101628 <vFappTest>
	//vFappIpStack();
}
  101650:	e49df004 	ldr	pc, [sp], #4

00101654 <vFappManager_Init>:
  101654:	e52de004 	str	lr, [sp, #-4]!
  101658:	ebfffff1 	bl	101624 <vFappTest_init>
  10165c:	e49df004 	ldr	pc, [sp], #4

00101660 <__aeabi_uidiv>:
  101660:	e2512001 	subs	r2, r1, #1	; 0x1
  101664:	012fff1e 	bxeq	lr
  101668:	3a000036 	bcc	101748 <__aeabi_uidiv+0xe8>
  10166c:	e1500001 	cmp	r0, r1
  101670:	9a000022 	bls	101700 <__aeabi_uidiv+0xa0>
  101674:	e1110002 	tst	r1, r2
  101678:	0a000023 	beq	10170c <__aeabi_uidiv+0xac>
  10167c:	e311020e 	tst	r1, #-536870912	; 0xe0000000
  101680:	01a01181 	moveq	r1, r1, lsl #3
  101684:	03a03008 	moveq	r3, #8	; 0x8
  101688:	13a03001 	movne	r3, #1	; 0x1
  10168c:	e3510201 	cmp	r1, #268435456	; 0x10000000
  101690:	31510000 	cmpcc	r1, r0
  101694:	31a01201 	movcc	r1, r1, lsl #4
  101698:	31a03203 	movcc	r3, r3, lsl #4
  10169c:	3afffffa 	bcc	10168c <__aeabi_uidiv+0x2c>
  1016a0:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
  1016a4:	31510000 	cmpcc	r1, r0
  1016a8:	31a01081 	movcc	r1, r1, lsl #1
  1016ac:	31a03083 	movcc	r3, r3, lsl #1
  1016b0:	3afffffa 	bcc	1016a0 <__aeabi_uidiv+0x40>
  1016b4:	e3a02000 	mov	r2, #0	; 0x0
  1016b8:	e1500001 	cmp	r0, r1
  1016bc:	20400001 	subcs	r0, r0, r1
  1016c0:	21822003 	orrcs	r2, r2, r3
  1016c4:	e15000a1 	cmp	r0, r1, lsr #1
  1016c8:	204000a1 	subcs	r0, r0, r1, lsr #1
  1016cc:	218220a3 	orrcs	r2, r2, r3, lsr #1
  1016d0:	e1500121 	cmp	r0, r1, lsr #2
  1016d4:	20400121 	subcs	r0, r0, r1, lsr #2
  1016d8:	21822123 	orrcs	r2, r2, r3, lsr #2
  1016dc:	e15001a1 	cmp	r0, r1, lsr #3
  1016e0:	204001a1 	subcs	r0, r0, r1, lsr #3
  1016e4:	218221a3 	orrcs	r2, r2, r3, lsr #3
  1016e8:	e3500000 	cmp	r0, #0	; 0x0
  1016ec:	11b03223 	movnes	r3, r3, lsr #4
  1016f0:	11a01221 	movne	r1, r1, lsr #4
  1016f4:	1affffef 	bne	1016b8 <__aeabi_uidiv+0x58>
  1016f8:	e1a00002 	mov	r0, r2
  1016fc:	e12fff1e 	bx	lr
  101700:	03a00001 	moveq	r0, #1	; 0x1
  101704:	13a00000 	movne	r0, #0	; 0x0
  101708:	e12fff1e 	bx	lr
  10170c:	e3510801 	cmp	r1, #65536	; 0x10000
  101710:	21a01821 	movcs	r1, r1, lsr #16
  101714:	23a02010 	movcs	r2, #16	; 0x10
  101718:	33a02000 	movcc	r2, #0	; 0x0
  10171c:	e3510c01 	cmp	r1, #256	; 0x100
  101720:	21a01421 	movcs	r1, r1, lsr #8
  101724:	22822008 	addcs	r2, r2, #8	; 0x8
  101728:	e3510010 	cmp	r1, #16	; 0x10
  10172c:	21a01221 	movcs	r1, r1, lsr #4
  101730:	22822004 	addcs	r2, r2, #4	; 0x4
  101734:	e3510004 	cmp	r1, #4	; 0x4
  101738:	82822003 	addhi	r2, r2, #3	; 0x3
  10173c:	908220a1 	addls	r2, r2, r1, lsr #1
  101740:	e1a00230 	mov	r0, r0, lsr r2
  101744:	e12fff1e 	bx	lr
  101748:	e52de008 	str	lr, [sp, #-8]!
  10174c:	eb000007 	bl	101770 <__aeabi_idiv0>
  101750:	e3a00000 	mov	r0, #0	; 0x0
  101754:	e49df008 	ldr	pc, [sp], #8

00101758 <__aeabi_uidivmod>:
  101758:	e92d4003 	stmdb	sp!, {r0, r1, lr}
  10175c:	ebffffbf 	bl	101660 <__aeabi_uidiv>
  101760:	e8bd4006 	ldmia	sp!, {r1, r2, lr}
  101764:	e0030092 	mul	r3, r2, r0
  101768:	e0411003 	sub	r1, r1, r3
  10176c:	e12fff1e 	bx	lr

00101770 <__aeabi_idiv0>:
  101770:	e12fff1e 	bx	lr

00101774 <free>:
  101774:	e59f3008 	ldr	r3, [pc, #8]	; 101784 <.text+0x1784>
  101778:	e1a01000 	mov	r1, r0
  10177c:	e5930000 	ldr	r0, [r3]
  101780:	ea0003db 	b	1026f4 <_free_r>
  101784:	00200420 	eoreq	r0, r0, r0, lsr #8

00101788 <malloc>:
  101788:	e59f3008 	ldr	r3, [pc, #8]	; 101798 <.text+0x1798>
  10178c:	e1a01000 	mov	r1, r0
  101790:	e5930000 	ldr	r0, [r3]
  101794:	ea000000 	b	10179c <_malloc_r>
  101798:	00200420 	eoreq	r0, r0, r0, lsr #8

0010179c <_malloc_r>:
  10179c:	e281300b 	add	r3, r1, #11	; 0xb
  1017a0:	e3530016 	cmp	r3, #22	; 0x16
  1017a4:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  1017a8:	83c35007 	bichi	r5, r3, #7	; 0x7
  1017ac:	93a05010 	movls	r5, #16	; 0x10
  1017b0:	93a03000 	movls	r3, #0	; 0x0
  1017b4:	81a03fa5 	movhi	r3, r5, lsr #31
  1017b8:	e1550001 	cmp	r5, r1
  1017bc:	33833001 	orrcc	r3, r3, #1	; 0x1
  1017c0:	e3530000 	cmp	r3, #0	; 0x0
  1017c4:	e1a07000 	mov	r7, r0
  1017c8:	13a0300c 	movne	r3, #12	; 0xc
  1017cc:	e24dd004 	sub	sp, sp, #4	; 0x4
  1017d0:	13a00000 	movne	r0, #0	; 0x0
  1017d4:	15873000 	strne	r3, [r7]
  1017d8:	1a000017 	bne	10183c <_malloc_r+0xa0>
  1017dc:	e1a00007 	mov	r0, r7
  1017e0:	eb0001c9 	bl	101f0c <__malloc_lock>
  1017e4:	e3550f7e 	cmp	r5, #504	; 0x1f8
  1017e8:	2a000015 	bcs	101844 <_malloc_r+0xa8>
  1017ec:	e59f86fc 	ldr	r8, [pc, #1788]	; 101ef0 <.text+0x1ef0>
  1017f0:	e1a021a5 	mov	r2, r5, lsr #3
  1017f4:	e0883182 	add	r3, r8, r2, lsl #3
  1017f8:	e593400c 	ldr	r4, [r3, #12]
  1017fc:	e1530004 	cmp	r3, r4
  101800:	e1a0a008 	mov	sl, r8
  101804:	0a0000cd 	beq	101b40 <_malloc_r+0x3a4>
  101808:	e5943004 	ldr	r3, [r4, #4]
  10180c:	e3c33003 	bic	r3, r3, #3	; 0x3
  101810:	e0843003 	add	r3, r4, r3
  101814:	e5932004 	ldr	r2, [r3, #4]
  101818:	e594000c 	ldr	r0, [r4, #12]
  10181c:	e5941008 	ldr	r1, [r4, #8]
  101820:	e3822001 	orr	r2, r2, #1	; 0x1
  101824:	e5801008 	str	r1, [r0, #8]
  101828:	e581000c 	str	r0, [r1, #12]
  10182c:	e5832004 	str	r2, [r3, #4]
  101830:	e1a00007 	mov	r0, r7
  101834:	eb0001b5 	bl	101f10 <__malloc_unlock>
  101838:	e2840008 	add	r0, r4, #8	; 0x8
  10183c:	e28dd004 	add	sp, sp, #4	; 0x4
  101840:	e8bd8ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  101844:	e1b024a5 	movs	r2, r5, lsr #9
  101848:	01a001a5 	moveq	r0, r5, lsr #3
  10184c:	01a03180 	moveq	r3, r0, lsl #3
  101850:	1a000027 	bne	1018f4 <_malloc_r+0x158>
  101854:	e59f8694 	ldr	r8, [pc, #1684]	; 101ef0 <.text+0x1ef0>
  101858:	e0831008 	add	r1, r3, r8
  10185c:	e591400c 	ldr	r4, [r1, #12]
  101860:	e1510004 	cmp	r1, r4
  101864:	e1a0a008 	mov	sl, r8
  101868:	1a000005 	bne	101884 <_malloc_r+0xe8>
  10186c:	ea00000a 	b	10189c <_malloc_r+0x100>
  101870:	e3520000 	cmp	r2, #0	; 0x0
  101874:	aa000047 	bge	101998 <_malloc_r+0x1fc>
  101878:	e594400c 	ldr	r4, [r4, #12]
  10187c:	e1510004 	cmp	r1, r4
  101880:	0a000005 	beq	10189c <_malloc_r+0x100>
  101884:	e5943004 	ldr	r3, [r4, #4]
  101888:	e3c33003 	bic	r3, r3, #3	; 0x3
  10188c:	e0652003 	rsb	r2, r5, r3
  101890:	e352000f 	cmp	r2, #15	; 0xf
  101894:	dafffff5 	ble	101870 <_malloc_r+0xd4>
  101898:	e2400001 	sub	r0, r0, #1	; 0x1
  10189c:	e280e001 	add	lr, r0, #1	; 0x1
  1018a0:	e59f664c 	ldr	r6, [pc, #1612]	; 101ef4 <.text+0x1ef4>
  1018a4:	e5964008 	ldr	r4, [r6, #8]
  1018a8:	e1560004 	cmp	r6, r4
  1018ac:	0a000076 	beq	101a8c <_malloc_r+0x2f0>
  1018b0:	e5943004 	ldr	r3, [r4, #4]
  1018b4:	e3c32003 	bic	r2, r3, #3	; 0x3
  1018b8:	e0650002 	rsb	r0, r5, r2
  1018bc:	e350000f 	cmp	r0, #15	; 0xf
  1018c0:	ca000027 	bgt	101964 <_malloc_r+0x1c8>
  1018c4:	e3500000 	cmp	r0, #0	; 0x0
  1018c8:	e586600c 	str	r6, [r6, #12]
  1018cc:	e5866008 	str	r6, [r6, #8]
  1018d0:	ba00003c 	blt	1019c8 <_malloc_r+0x22c>
  1018d4:	e0842002 	add	r2, r4, r2
  1018d8:	e5923004 	ldr	r3, [r2, #4]
  1018dc:	e3833001 	orr	r3, r3, #1	; 0x1
  1018e0:	e1a00007 	mov	r0, r7
  1018e4:	e5823004 	str	r3, [r2, #4]
  1018e8:	eb000188 	bl	101f10 <__malloc_unlock>
  1018ec:	e2840008 	add	r0, r4, #8	; 0x8
  1018f0:	eaffffd1 	b	10183c <_malloc_r+0xa0>
  1018f4:	e3520004 	cmp	r2, #4	; 0x4
  1018f8:	91a03325 	movls	r3, r5, lsr #6
  1018fc:	92830038 	addls	r0, r3, #56	; 0x38
  101900:	91a03180 	movls	r3, r0, lsl #3
  101904:	9affffd2 	bls	101854 <_malloc_r+0xb8>
  101908:	e3520014 	cmp	r2, #20	; 0x14
  10190c:	9282005b 	addls	r0, r2, #91	; 0x5b
  101910:	91a03180 	movls	r3, r0, lsl #3
  101914:	9affffce 	bls	101854 <_malloc_r+0xb8>
  101918:	e3520054 	cmp	r2, #84	; 0x54
  10191c:	91a03625 	movls	r3, r5, lsr #12
  101920:	9283006e 	addls	r0, r3, #110	; 0x6e
  101924:	91a03180 	movls	r3, r0, lsl #3
  101928:	9affffc9 	bls	101854 <_malloc_r+0xb8>
  10192c:	e3520f55 	cmp	r2, #340	; 0x154
  101930:	91a037a5 	movls	r3, r5, lsr #15
  101934:	92830077 	addls	r0, r3, #119	; 0x77
  101938:	91a03180 	movls	r3, r0, lsl #3
  10193c:	9affffc4 	bls	101854 <_malloc_r+0xb8>
  101940:	e3a03e55 	mov	r3, #1360	; 0x550
  101944:	e2833004 	add	r3, r3, #4	; 0x4
  101948:	e1520003 	cmp	r2, r3
  10194c:	91a03925 	movls	r3, r5, lsr #18
  101950:	9283007c 	addls	r0, r3, #124	; 0x7c
  101954:	83a0007e 	movhi	r0, #126	; 0x7e
  101958:	82433f59 	subhi	r3, r3, #356	; 0x164
  10195c:	91a03180 	movls	r3, r0, lsl #3
  101960:	eaffffbb 	b	101854 <_malloc_r+0xb8>
  101964:	e0842005 	add	r2, r4, r5
  101968:	e3801001 	orr	r1, r0, #1	; 0x1
  10196c:	e3853001 	orr	r3, r5, #1	; 0x1
  101970:	e7820000 	str	r0, [r2, r0]
  101974:	e5843004 	str	r3, [r4, #4]
  101978:	e586200c 	str	r2, [r6, #12]
  10197c:	e5862008 	str	r2, [r6, #8]
  101980:	e1a00007 	mov	r0, r7
  101984:	e9820042 	stmib	r2, {r1, r6}
  101988:	e582600c 	str	r6, [r2, #12]
  10198c:	eb00015f 	bl	101f10 <__malloc_unlock>
  101990:	e2840008 	add	r0, r4, #8	; 0x8
  101994:	eaffffa8 	b	10183c <_malloc_r+0xa0>
  101998:	e0840003 	add	r0, r4, r3
  10199c:	e5903004 	ldr	r3, [r0, #4]
  1019a0:	e594100c 	ldr	r1, [r4, #12]
  1019a4:	e5942008 	ldr	r2, [r4, #8]
  1019a8:	e3833001 	orr	r3, r3, #1	; 0x1
  1019ac:	e5803004 	str	r3, [r0, #4]
  1019b0:	e5812008 	str	r2, [r1, #8]
  1019b4:	e1a00007 	mov	r0, r7
  1019b8:	e582100c 	str	r1, [r2, #12]
  1019bc:	eb000153 	bl	101f10 <__malloc_unlock>
  1019c0:	e2840008 	add	r0, r4, #8	; 0x8
  1019c4:	eaffff9c 	b	10183c <_malloc_r+0xa0>
  1019c8:	e3520c02 	cmp	r2, #512	; 0x200
  1019cc:	3a0000a0 	bcc	101c54 <_malloc_r+0x4b8>
  1019d0:	e1b014a2 	movs	r1, r2, lsr #9
  1019d4:	01a011a2 	moveq	r1, r2, lsr #3
  1019d8:	01a03181 	moveq	r3, r1, lsl #3
  1019dc:	0a00001a 	beq	101a4c <_malloc_r+0x2b0>
  1019e0:	e3510004 	cmp	r1, #4	; 0x4
  1019e4:	91a03322 	movls	r3, r2, lsr #6
  1019e8:	92831038 	addls	r1, r3, #56	; 0x38
  1019ec:	91a03181 	movls	r3, r1, lsl #3
  1019f0:	9a000015 	bls	101a4c <_malloc_r+0x2b0>
  1019f4:	e3510014 	cmp	r1, #20	; 0x14
  1019f8:	9281105b 	addls	r1, r1, #91	; 0x5b
  1019fc:	91a03181 	movls	r3, r1, lsl #3
  101a00:	9a000011 	bls	101a4c <_malloc_r+0x2b0>
  101a04:	e3510054 	cmp	r1, #84	; 0x54
  101a08:	91a03622 	movls	r3, r2, lsr #12
  101a0c:	9283106e 	addls	r1, r3, #110	; 0x6e
  101a10:	91a03181 	movls	r3, r1, lsl #3
  101a14:	9a00000c 	bls	101a4c <_malloc_r+0x2b0>
  101a18:	e3510f55 	cmp	r1, #340	; 0x154
  101a1c:	91a037a2 	movls	r3, r2, lsr #15
  101a20:	92831077 	addls	r1, r3, #119	; 0x77
  101a24:	91a03181 	movls	r3, r1, lsl #3
  101a28:	9a000007 	bls	101a4c <_malloc_r+0x2b0>
  101a2c:	e3a03e55 	mov	r3, #1360	; 0x550
  101a30:	e2833004 	add	r3, r3, #4	; 0x4
  101a34:	e1510003 	cmp	r1, r3
  101a38:	91a03922 	movls	r3, r2, lsr #18
  101a3c:	9283107c 	addls	r1, r3, #124	; 0x7c
  101a40:	83a0107e 	movhi	r1, #126	; 0x7e
  101a44:	82433f59 	subhi	r3, r3, #356	; 0x164
  101a48:	91a03181 	movls	r3, r1, lsl #3
  101a4c:	e088c003 	add	ip, r8, r3
  101a50:	e59c0008 	ldr	r0, [ip, #8]
  101a54:	e15c0000 	cmp	ip, r0
  101a58:	0a0000eb 	beq	101e0c <_malloc_r+0x670>
  101a5c:	e5903004 	ldr	r3, [r0, #4]
  101a60:	e3c33003 	bic	r3, r3, #3	; 0x3
  101a64:	e1520003 	cmp	r2, r3
  101a68:	2a000002 	bcs	101a78 <_malloc_r+0x2dc>
  101a6c:	e5900008 	ldr	r0, [r0, #8]
  101a70:	e15c0000 	cmp	ip, r0
  101a74:	1afffff8 	bne	101a5c <_malloc_r+0x2c0>
  101a78:	e590c00c 	ldr	ip, [r0, #12]
  101a7c:	e584c00c 	str	ip, [r4, #12]
  101a80:	e5840008 	str	r0, [r4, #8]
  101a84:	e580400c 	str	r4, [r0, #12]
  101a88:	e58c4008 	str	r4, [ip, #8]
  101a8c:	e59a0004 	ldr	r0, [sl, #4]
  101a90:	e35e0000 	cmp	lr, #0	; 0x0
  101a94:	e28e3003 	add	r3, lr, #3	; 0x3
  101a98:	a1a0300e 	movge	r3, lr
  101a9c:	e1a03143 	mov	r3, r3, asr #2
  101aa0:	e3a02001 	mov	r2, #1	; 0x1
  101aa4:	e1a02312 	mov	r2, r2, lsl r3
  101aa8:	e1520000 	cmp	r2, r0
  101aac:	8a000029 	bhi	101b58 <_malloc_r+0x3bc>
  101ab0:	e1120000 	tst	r2, r0
  101ab4:	0a000073 	beq	101c88 <_malloc_r+0x4ec>
  101ab8:	e088918e 	add	r9, r8, lr, lsl #3
  101abc:	e1a0a00e 	mov	sl, lr
  101ac0:	e1a01009 	mov	r1, r9
  101ac4:	e591400c 	ldr	r4, [r1, #12]
  101ac8:	e1510004 	cmp	r1, r4
  101acc:	1a000005 	bne	101ae8 <_malloc_r+0x34c>
  101ad0:	ea000076 	b	101cb0 <_malloc_r+0x514>
  101ad4:	e35c0000 	cmp	ip, #0	; 0x0
  101ad8:	aa000079 	bge	101cc4 <_malloc_r+0x528>
  101adc:	e594400c 	ldr	r4, [r4, #12]
  101ae0:	e1510004 	cmp	r1, r4
  101ae4:	0a000071 	beq	101cb0 <_malloc_r+0x514>
  101ae8:	e5943004 	ldr	r3, [r4, #4]
  101aec:	e3c33003 	bic	r3, r3, #3	; 0x3
  101af0:	e065c003 	rsb	ip, r5, r3
  101af4:	e35c000f 	cmp	ip, #15	; 0xf
  101af8:	dafffff5 	ble	101ad4 <_malloc_r+0x338>
  101afc:	e3853001 	orr	r3, r5, #1	; 0x1
  101b00:	e0842005 	add	r2, r4, r5
  101b04:	e594000c 	ldr	r0, [r4, #12]
  101b08:	e5843004 	str	r3, [r4, #4]
  101b0c:	e5b41008 	ldr	r1, [r4, #8]!
  101b10:	e38c3001 	orr	r3, ip, #1	; 0x1
  101b14:	e5801008 	str	r1, [r0, #8]
  101b18:	e581000c 	str	r0, [r1, #12]
  101b1c:	e5862008 	str	r2, [r6, #8]
  101b20:	e586200c 	str	r2, [r6, #12]
  101b24:	e1a00007 	mov	r0, r7
  101b28:	e782c00c 	str	ip, [r2, ip]
  101b2c:	e9820048 	stmib	r2, {r3, r6}
  101b30:	e582600c 	str	r6, [r2, #12]
  101b34:	eb0000f5 	bl	101f10 <__malloc_unlock>
  101b38:	e1a00004 	mov	r0, r4
  101b3c:	eaffff3e 	b	10183c <_malloc_r+0xa0>
  101b40:	e2843008 	add	r3, r4, #8	; 0x8
  101b44:	e593400c 	ldr	r4, [r3, #12]
  101b48:	e1530004 	cmp	r3, r4
  101b4c:	1affff2d 	bne	101808 <_malloc_r+0x6c>
  101b50:	e282e002 	add	lr, r2, #2	; 0x2
  101b54:	eaffff51 	b	1018a0 <_malloc_r+0x104>
  101b58:	e59f2390 	ldr	r2, [pc, #912]	; 101ef0 <.text+0x1ef0>
  101b5c:	e5924008 	ldr	r4, [r2, #8]
  101b60:	e5943004 	ldr	r3, [r4, #4]
  101b64:	e3c38003 	bic	r8, r3, #3	; 0x3
  101b68:	e0650008 	rsb	r0, r5, r8
  101b6c:	e350000f 	cmp	r0, #15	; 0xf
  101b70:	c3a03000 	movgt	r3, #0	; 0x0
  101b74:	d3a03001 	movle	r3, #1	; 0x1
  101b78:	e1550008 	cmp	r5, r8
  101b7c:	83833001 	orrhi	r3, r3, #1	; 0x1
  101b80:	e3530000 	cmp	r3, #0	; 0x0
  101b84:	e1a09004 	mov	r9, r4
  101b88:	0a000026 	beq	101c28 <_malloc_r+0x48c>
  101b8c:	e59f3364 	ldr	r3, [pc, #868]	; 101ef8 <.text+0x1ef8>
  101b90:	e59fb364 	ldr	fp, [pc, #868]	; 101efc <.text+0x1efc>
  101b94:	e5932000 	ldr	r2, [r3]
  101b98:	e59b1000 	ldr	r1, [fp]
  101b9c:	e2822010 	add	r2, r2, #16	; 0x10
  101ba0:	e3710001 	cmn	r1, #1	; 0x1
  101ba4:	e0856002 	add	r6, r5, r2
  101ba8:	12863eff 	addne	r3, r6, #4080	; 0xff0
  101bac:	1283300f 	addne	r3, r3, #15	; 0xf
  101bb0:	13c36eff 	bicne	r6, r3, #4080	; 0xff0
  101bb4:	13c6600f 	bicne	r6, r6, #15	; 0xf
  101bb8:	e1a00007 	mov	r0, r7
  101bbc:	e1a01006 	mov	r1, r6
  101bc0:	ebfff925 	bl	10005c <_sbrk_r>
  101bc4:	e3700001 	cmn	r0, #1	; 0x1
  101bc8:	0a00008c 	beq	101e00 <_malloc_r+0x664>
  101bcc:	e0841008 	add	r1, r4, r8
  101bd0:	e1510000 	cmp	r1, r0
  101bd4:	e1a0a000 	mov	sl, r0
  101bd8:	9a000045 	bls	101cf4 <_malloc_r+0x558>
  101bdc:	e59f330c 	ldr	r3, [pc, #780]	; 101ef0 <.text+0x1ef0>
  101be0:	e1540003 	cmp	r4, r3
  101be4:	0a0000a5 	beq	101e80 <_malloc_r+0x6e4>
  101be8:	e59f3300 	ldr	r3, [pc, #768]	; 101ef0 <.text+0x1ef0>
  101bec:	e5934008 	ldr	r4, [r3, #8]
  101bf0:	e5942004 	ldr	r2, [r4, #4]
  101bf4:	e3c22003 	bic	r2, r2, #3	; 0x3
  101bf8:	e0650002 	rsb	r0, r5, r2
  101bfc:	e350000f 	cmp	r0, #15	; 0xf
  101c00:	c3a03000 	movgt	r3, #0	; 0x0
  101c04:	d3a03001 	movle	r3, #1	; 0x1
  101c08:	e1550002 	cmp	r5, r2
  101c0c:	83833001 	orrhi	r3, r3, #1	; 0x1
  101c10:	e3530000 	cmp	r3, #0	; 0x0
  101c14:	0a000003 	beq	101c28 <_malloc_r+0x48c>
  101c18:	e1a00007 	mov	r0, r7
  101c1c:	eb0000bb 	bl	101f10 <__malloc_unlock>
  101c20:	e3a00000 	mov	r0, #0	; 0x0
  101c24:	eaffff04 	b	10183c <_malloc_r+0xa0>
  101c28:	e0841005 	add	r1, r4, r5
  101c2c:	e3802001 	orr	r2, r0, #1	; 0x1
  101c30:	e3853001 	orr	r3, r5, #1	; 0x1
  101c34:	e5843004 	str	r3, [r4, #4]
  101c38:	e5812004 	str	r2, [r1, #4]
  101c3c:	e59f22ac 	ldr	r2, [pc, #684]	; 101ef0 <.text+0x1ef0>
  101c40:	e1a00007 	mov	r0, r7
  101c44:	e5821008 	str	r1, [r2, #8]
  101c48:	eb0000b0 	bl	101f10 <__malloc_unlock>
  101c4c:	e2840008 	add	r0, r4, #8	; 0x8
  101c50:	eafffef9 	b	10183c <_malloc_r+0xa0>
  101c54:	e1a021a2 	mov	r2, r2, lsr #3
  101c58:	e59a0004 	ldr	r0, [sl, #4]
  101c5c:	e1a01122 	mov	r1, r2, lsr #2
  101c60:	e3a03001 	mov	r3, #1	; 0x1
  101c64:	e1800113 	orr	r0, r0, r3, lsl r1
  101c68:	e0882182 	add	r2, r8, r2, lsl #3
  101c6c:	e5923008 	ldr	r3, [r2, #8]
  101c70:	e584200c 	str	r2, [r4, #12]
  101c74:	e5843008 	str	r3, [r4, #8]
  101c78:	e58a0004 	str	r0, [sl, #4]
  101c7c:	e583400c 	str	r4, [r3, #12]
  101c80:	e5824008 	str	r4, [r2, #8]
  101c84:	eaffff81 	b	101a90 <_malloc_r+0x2f4>
  101c88:	e1a02082 	mov	r2, r2, lsl #1
  101c8c:	e3ce3003 	bic	r3, lr, #3	; 0x3
  101c90:	e1100002 	tst	r0, r2
  101c94:	e283e004 	add	lr, r3, #4	; 0x4
  101c98:	1affff86 	bne	101ab8 <_malloc_r+0x31c>
  101c9c:	e1a02082 	mov	r2, r2, lsl #1
  101ca0:	e1100002 	tst	r0, r2
  101ca4:	e28ee004 	add	lr, lr, #4	; 0x4
  101ca8:	0afffffb 	beq	101c9c <_malloc_r+0x500>
  101cac:	eaffff81 	b	101ab8 <_malloc_r+0x31c>
  101cb0:	e28aa001 	add	sl, sl, #1	; 0x1
  101cb4:	e31a0003 	tst	sl, #3	; 0x3
  101cb8:	0a000059 	beq	101e24 <_malloc_r+0x688>
  101cbc:	e2811008 	add	r1, r1, #8	; 0x8
  101cc0:	eaffff7f 	b	101ac4 <_malloc_r+0x328>
  101cc4:	e0841003 	add	r1, r4, r3
  101cc8:	e5913004 	ldr	r3, [r1, #4]
  101ccc:	e594000c 	ldr	r0, [r4, #12]
  101cd0:	e5b42008 	ldr	r2, [r4, #8]!
  101cd4:	e3833001 	orr	r3, r3, #1	; 0x1
  101cd8:	e5802008 	str	r2, [r0, #8]
  101cdc:	e582000c 	str	r0, [r2, #12]
  101ce0:	e5813004 	str	r3, [r1, #4]
  101ce4:	e1a00007 	mov	r0, r7
  101ce8:	eb000088 	bl	101f10 <__malloc_unlock>
  101cec:	e1a00004 	mov	r0, r4
  101cf0:	eafffed1 	b	10183c <_malloc_r+0xa0>
  101cf4:	e59fc204 	ldr	ip, [pc, #516]	; 101f00 <.text+0x1f00>
  101cf8:	e59c3000 	ldr	r3, [ip]
  101cfc:	e0862003 	add	r2, r6, r3
  101d00:	e58c2000 	str	r2, [ip]
  101d04:	0a000062 	beq	101e94 <_malloc_r+0x6f8>
  101d08:	e59b3000 	ldr	r3, [fp]
  101d0c:	e3730001 	cmn	r3, #1	; 0x1
  101d10:	10613000 	rsbne	r3, r1, r0
  101d14:	059f31e0 	ldreq	r3, [pc, #480]	; 101efc <.text+0x1efc>
  101d18:	10823003 	addne	r3, r2, r3
  101d1c:	05830000 	streq	r0, [r3]
  101d20:	158c3000 	strne	r3, [ip]
  101d24:	e2103007 	ands	r3, r0, #7	; 0x7
  101d28:	12631008 	rsbne	r1, r3, #8	; 0x8
  101d2c:	1080a001 	addne	sl, r0, r1
  101d30:	01a01003 	moveq	r1, r3
  101d34:	e08a3006 	add	r3, sl, r6
  101d38:	e1a03a03 	mov	r3, r3, lsl #20
  101d3c:	e1a03a23 	mov	r3, r3, lsr #20
  101d40:	e2633a01 	rsb	r3, r3, #4096	; 0x1000
  101d44:	e0814003 	add	r4, r1, r3
  101d48:	e1a01004 	mov	r1, r4
  101d4c:	e1a00007 	mov	r0, r7
  101d50:	e58dc000 	str	ip, [sp]
  101d54:	ebfff8c0 	bl	10005c <_sbrk_r>
  101d58:	e3700001 	cmn	r0, #1	; 0x1
  101d5c:	106a3000 	rsbne	r3, sl, r0
  101d60:	e59dc000 	ldr	ip, [sp]
  101d64:	10833004 	addne	r3, r3, r4
  101d68:	13830001 	orrne	r0, r3, #1	; 0x1
  101d6c:	e59f217c 	ldr	r2, [pc, #380]	; 101ef0 <.text+0x1ef0>
  101d70:	e59c3000 	ldr	r3, [ip]
  101d74:	03a04000 	moveq	r4, #0	; 0x0
  101d78:	02800002 	addeq	r0, r0, #2	; 0x2
  101d7c:	e0843003 	add	r3, r4, r3
  101d80:	e1590002 	cmp	r9, r2
  101d84:	e1a0400a 	mov	r4, sl
  101d88:	e58c3000 	str	r3, [ip]
  101d8c:	e58a0004 	str	r0, [sl, #4]
  101d90:	e582a008 	str	sl, [r2, #8]
  101d94:	0a00000f 	beq	101dd8 <_malloc_r+0x63c>
  101d98:	e358000f 	cmp	r8, #15	; 0xf
  101d9c:	93a03001 	movls	r3, #1	; 0x1
  101da0:	958a3004 	strls	r3, [sl, #4]
  101da4:	9affff91 	bls	101bf0 <_malloc_r+0x454>
  101da8:	e5993004 	ldr	r3, [r9, #4]
  101dac:	e248200c 	sub	r2, r8, #12	; 0xc
  101db0:	e3c22007 	bic	r2, r2, #7	; 0x7
  101db4:	e2033001 	and	r3, r3, #1	; 0x1
  101db8:	e1823003 	orr	r3, r2, r3
  101dbc:	e3a01005 	mov	r1, #5	; 0x5
  101dc0:	e352000f 	cmp	r2, #15	; 0xf
  101dc4:	e0892002 	add	r2, r9, r2
  101dc8:	e5893004 	str	r3, [r9, #4]
  101dcc:	e5821008 	str	r1, [r2, #8]
  101dd0:	e5821004 	str	r1, [r2, #4]
  101dd4:	8a000038 	bhi	101ebc <_malloc_r+0x720>
  101dd8:	e59f1124 	ldr	r1, [pc, #292]	; 101f04 <.text+0x1f04>
  101ddc:	e59c2000 	ldr	r2, [ip]
  101de0:	e5913000 	ldr	r3, [r1]
  101de4:	e1520003 	cmp	r2, r3
  101de8:	85812000 	strhi	r2, [r1]
  101dec:	e59f1114 	ldr	r1, [pc, #276]	; 101f08 <.text+0x1f08>
  101df0:	e5913000 	ldr	r3, [r1]
  101df4:	e1520003 	cmp	r2, r3
  101df8:	85812000 	strhi	r2, [r1]
  101dfc:	eaffff7b 	b	101bf0 <_malloc_r+0x454>
  101e00:	e59f20e8 	ldr	r2, [pc, #232]	; 101ef0 <.text+0x1ef0>
  101e04:	e5924008 	ldr	r4, [r2, #8]
  101e08:	eaffff78 	b	101bf0 <_malloc_r+0x454>
  101e0c:	e59a3004 	ldr	r3, [sl, #4]
  101e10:	e1a01121 	mov	r1, r1, lsr #2
  101e14:	e3a02001 	mov	r2, #1	; 0x1
  101e18:	e1833112 	orr	r3, r3, r2, lsl r1
  101e1c:	e58a3004 	str	r3, [sl, #4]
  101e20:	eaffff15 	b	101a7c <_malloc_r+0x2e0>
  101e24:	e1a0c00e 	mov	ip, lr
  101e28:	e1a01009 	mov	r1, r9
  101e2c:	e31c0003 	tst	ip, #3	; 0x3
  101e30:	e2411008 	sub	r1, r1, #8	; 0x8
  101e34:	e24cc001 	sub	ip, ip, #1	; 0x1
  101e38:	0a000027 	beq	101edc <_malloc_r+0x740>
  101e3c:	e5913008 	ldr	r3, [r1, #8]
  101e40:	e1530001 	cmp	r3, r1
  101e44:	0afffff8 	beq	101e2c <_malloc_r+0x690>
  101e48:	e1a02082 	mov	r2, r2, lsl #1
  101e4c:	e1520000 	cmp	r2, r0
  101e50:	8affff40 	bhi	101b58 <_malloc_r+0x3bc>
  101e54:	e3520000 	cmp	r2, #0	; 0x0
  101e58:	0affff3e 	beq	101b58 <_malloc_r+0x3bc>
  101e5c:	e1120000 	tst	r2, r0
  101e60:	11a0e00a 	movne	lr, sl
  101e64:	1affff13 	bne	101ab8 <_malloc_r+0x31c>
  101e68:	e1a02082 	mov	r2, r2, lsl #1
  101e6c:	e1100002 	tst	r0, r2
  101e70:	e28aa004 	add	sl, sl, #4	; 0x4
  101e74:	0afffffb 	beq	101e68 <_malloc_r+0x6cc>
  101e78:	e1a0e00a 	mov	lr, sl
  101e7c:	eaffff0d 	b	101ab8 <_malloc_r+0x31c>
  101e80:	e59fc078 	ldr	ip, [pc, #120]	; 101f00 <.text+0x1f00>
  101e84:	e59c3000 	ldr	r3, [ip]
  101e88:	e0862003 	add	r2, r6, r3
  101e8c:	e58c2000 	str	r2, [ip]
  101e90:	eaffff9c 	b	101d08 <_malloc_r+0x56c>
  101e94:	e1a03a00 	mov	r3, r0, lsl #20
  101e98:	e1a03a23 	mov	r3, r3, lsr #20
  101e9c:	e3530000 	cmp	r3, #0	; 0x0
  101ea0:	1affff98 	bne	101d08 <_malloc_r+0x56c>
  101ea4:	e59f2044 	ldr	r2, [pc, #68]	; 101ef0 <.text+0x1ef0>
  101ea8:	e0863008 	add	r3, r6, r8
  101eac:	e5924008 	ldr	r4, [r2, #8]
  101eb0:	e3833001 	orr	r3, r3, #1	; 0x1
  101eb4:	e5843004 	str	r3, [r4, #4]
  101eb8:	eaffffc6 	b	101dd8 <_malloc_r+0x63c>
  101ebc:	e2891008 	add	r1, r9, #8	; 0x8
  101ec0:	e1a00007 	mov	r0, r7
  101ec4:	e58dc000 	str	ip, [sp]
  101ec8:	eb000209 	bl	1026f4 <_free_r>
  101ecc:	e59f301c 	ldr	r3, [pc, #28]	; 101ef0 <.text+0x1ef0>
  101ed0:	e59dc000 	ldr	ip, [sp]
  101ed4:	e5934008 	ldr	r4, [r3, #8]
  101ed8:	eaffffbe 	b	101dd8 <_malloc_r+0x63c>
  101edc:	e1e03002 	mvn	r3, r2
  101ee0:	e0000003 	and	r0, r0, r3
  101ee4:	e59f3004 	ldr	r3, [pc, #4]	; 101ef0 <.text+0x1ef0>
  101ee8:	e5830004 	str	r0, [r3, #4]
  101eec:	eaffffd5 	b	101e48 <_malloc_r+0x6ac>
  101ef0:	00200010 	eoreq	r0, r0, r0, lsl r0
  101ef4:	00200018 	eoreq	r0, r0, r8, lsl r0
  101ef8:	002009d4 	ldreqd	r0, [r0], -r4
  101efc:	0020041c 	eoreq	r0, r0, ip, lsl r4
  101f00:	002009e0 	eoreq	r0, r0, r0, ror #19
  101f04:	002009d8 	ldreqd	r0, [r0], -r8
  101f08:	002009dc 	ldreqd	r0, [r0], -ip

00101f0c <__malloc_lock>:
  101f0c:	e12fff1e 	bx	lr

00101f10 <__malloc_unlock>:
  101f10:	e12fff1e 	bx	lr

00101f14 <realloc>:
  101f14:	e1a02001 	mov	r2, r1
  101f18:	e59f100c 	ldr	r1, [pc, #12]	; 101f2c <.text+0x1f2c>
  101f1c:	e1a03000 	mov	r3, r0
  101f20:	e5910000 	ldr	r0, [r1]
  101f24:	e1a01003 	mov	r1, r3
  101f28:	ea000000 	b	101f30 <_realloc_r>
  101f2c:	00200420 	eoreq	r0, r0, r0, lsr #8

00101f30 <_realloc_r>:
  101f30:	e92d4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  101f34:	e251a000 	subs	sl, r1, #0	; 0x0
  101f38:	e24dd00c 	sub	sp, sp, #12	; 0xc
  101f3c:	e1a06002 	mov	r6, r2
  101f40:	e58d0000 	str	r0, [sp]
  101f44:	0a00008d 	beq	102180 <_realloc_r+0x250>
  101f48:	ebffffef 	bl	101f0c <__malloc_lock>
  101f4c:	e286300b 	add	r3, r6, #11	; 0xb
  101f50:	e3530016 	cmp	r3, #22	; 0x16
  101f54:	83c3e007 	bichi	lr, r3, #7	; 0x7
  101f58:	93a0e010 	movls	lr, #16	; 0x10
  101f5c:	958de004 	strls	lr, [sp, #4]
  101f60:	858de004 	strhi	lr, [sp, #4]
  101f64:	e59d0004 	ldr	r0, [sp, #4]
  101f68:	93a03000 	movls	r3, #0	; 0x0
  101f6c:	81a03fae 	movhi	r3, lr, lsr #31
  101f70:	e1500006 	cmp	r0, r6
  101f74:	33833001 	orrcc	r3, r3, #1	; 0x1
  101f78:	e24a5008 	sub	r5, sl, #8	; 0x8
  101f7c:	e3530000 	cmp	r3, #0	; 0x0
  101f80:	e5959004 	ldr	r9, [r5, #4]
  101f84:	1a0000d0 	bne	1022cc <_realloc_r+0x39c>
  101f88:	e3c94003 	bic	r4, r9, #3	; 0x3
  101f8c:	e154000e 	cmp	r4, lr
  101f90:	a1a08005 	movge	r8, r5
  101f94:	a1a07004 	movge	r7, r4
  101f98:	a1a0c008 	movge	ip, r8
  101f9c:	a2884008 	addge	r4, r8, #8	; 0x8
  101fa0:	aa00004a 	bge	1020d0 <_realloc_r+0x1a0>
  101fa4:	e59f25b8 	ldr	r2, [pc, #1464]	; 102564 <.text+0x2564>
  101fa8:	e592b008 	ldr	fp, [r2, #8]
  101fac:	e0850004 	add	r0, r5, r4
  101fb0:	e150000b 	cmp	r0, fp
  101fb4:	e1a08005 	mov	r8, r5
  101fb8:	0a0000c8 	beq	1022e0 <_realloc_r+0x3b0>
  101fbc:	e5901004 	ldr	r1, [r0, #4]
  101fc0:	e3c13001 	bic	r3, r1, #1	; 0x1
  101fc4:	e0833000 	add	r3, r3, r0
  101fc8:	e5932004 	ldr	r2, [r3, #4]
  101fcc:	e3120001 	tst	r2, #1	; 0x1
  101fd0:	0a00005f 	beq	102154 <_realloc_r+0x224>
  101fd4:	e3a0c000 	mov	ip, #0	; 0x0
  101fd8:	e1a0000c 	mov	r0, ip
  101fdc:	e3190001 	tst	r9, #1	; 0x1
  101fe0:	1a00006a 	bne	102190 <_realloc_r+0x260>
  101fe4:	e5953000 	ldr	r3, [r5]
  101fe8:	e0633005 	rsb	r3, r3, r5
  101fec:	e5932004 	ldr	r2, [r3, #4]
  101ff0:	e3500000 	cmp	r0, #0	; 0x0
  101ff4:	e58d3008 	str	r3, [sp, #8]
  101ff8:	e3c22003 	bic	r2, r2, #3	; 0x3
  101ffc:	0a000083 	beq	102210 <_realloc_r+0x2e0>
  102000:	e150000b 	cmp	r0, fp
  102004:	0a0000f9 	beq	1023f0 <_realloc_r+0x4c0>
  102008:	e0849002 	add	r9, r4, r2
  10200c:	e08c7009 	add	r7, ip, r9
  102010:	e157000e 	cmp	r7, lr
  102014:	ba00007e 	blt	102214 <_realloc_r+0x2e4>
  102018:	e2802008 	add	r2, r0, #8	; 0x8
  10201c:	e892000c 	ldmia	r2, {r2, r3}
  102020:	e5832008 	str	r2, [r3, #8]
  102024:	e582300c 	str	r3, [r2, #12]
  102028:	e59d3008 	ldr	r3, [sp, #8]
  10202c:	e2444004 	sub	r4, r4, #4	; 0x4
  102030:	e593200c 	ldr	r2, [r3, #12]
  102034:	e59d8008 	ldr	r8, [sp, #8]
  102038:	e5933008 	ldr	r3, [r3, #8]
  10203c:	e3540024 	cmp	r4, #36	; 0x24
  102040:	e5823008 	str	r3, [r2, #8]
  102044:	e583200c 	str	r2, [r3, #12]
  102048:	e2885008 	add	r5, r8, #8	; 0x8
  10204c:	8a0000d4 	bhi	1023a4 <_realloc_r+0x474>
  102050:	e3540013 	cmp	r4, #19	; 0x13
  102054:	e1a0c00a 	mov	ip, sl
  102058:	e1a0e005 	mov	lr, r5
  10205c:	9a000011 	bls	1020a8 <_realloc_r+0x178>
  102060:	e1a0000a 	mov	r0, sl
  102064:	e4903004 	ldr	r3, [r0], #4
  102068:	e5883008 	str	r3, [r8, #8]
  10206c:	e59a2004 	ldr	r2, [sl, #4]
  102070:	e354001b 	cmp	r4, #27	; 0x1b
  102074:	e588200c 	str	r2, [r8, #12]
  102078:	e288e010 	add	lr, r8, #16	; 0x10
  10207c:	e280c004 	add	ip, r0, #4	; 0x4
  102080:	9a000008 	bls	1020a8 <_realloc_r+0x178>
  102084:	e5903004 	ldr	r3, [r0, #4]
  102088:	e5883010 	str	r3, [r8, #16]
  10208c:	e59c2004 	ldr	r2, [ip, #4]
  102090:	e28c3004 	add	r3, ip, #4	; 0x4
  102094:	e3540024 	cmp	r4, #36	; 0x24
  102098:	e5882014 	str	r2, [r8, #20]
  10209c:	e288e018 	add	lr, r8, #24	; 0x18
  1020a0:	e283c004 	add	ip, r3, #4	; 0x4
  1020a4:	0a000119 	beq	102510 <_realloc_r+0x5e0>
  1020a8:	e1a0200c 	mov	r2, ip
  1020ac:	e4920004 	ldr	r0, [r2], #4
  1020b0:	e1a0100e 	mov	r1, lr
  1020b4:	e4810004 	str	r0, [r1], #4
  1020b8:	e59c3004 	ldr	r3, [ip, #4]
  1020bc:	e58e3004 	str	r3, [lr, #4]
  1020c0:	e5920004 	ldr	r0, [r2, #4]
  1020c4:	e59dc008 	ldr	ip, [sp, #8]
  1020c8:	e5810004 	str	r0, [r1, #4]
  1020cc:	e1a04005 	mov	r4, r5
  1020d0:	e59d1004 	ldr	r1, [sp, #4]
  1020d4:	e0610007 	rsb	r0, r1, r7
  1020d8:	e350000f 	cmp	r0, #15	; 0xf
  1020dc:	8a00000d 	bhi	102118 <_realloc_r+0x1e8>
  1020e0:	e59c3004 	ldr	r3, [ip, #4]
  1020e4:	e2033001 	and	r3, r3, #1	; 0x1
  1020e8:	e1873003 	orr	r3, r7, r3
  1020ec:	e58c3004 	str	r3, [ip, #4]
  1020f0:	e0872008 	add	r2, r7, r8
  1020f4:	e5923004 	ldr	r3, [r2, #4]
  1020f8:	e3833001 	orr	r3, r3, #1	; 0x1
  1020fc:	e5823004 	str	r3, [r2, #4]
  102100:	e59d0000 	ldr	r0, [sp]
  102104:	ebffff81 	bl	101f10 <__malloc_unlock>
  102108:	e1a06004 	mov	r6, r4
  10210c:	e1a00006 	mov	r0, r6
  102110:	e28dd00c 	add	sp, sp, #12	; 0xc
  102114:	e8bd8ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  102118:	e59c3004 	ldr	r3, [ip, #4]
  10211c:	e2033001 	and	r3, r3, #1	; 0x1
  102120:	e1813003 	orr	r3, r1, r3
  102124:	e3802001 	orr	r2, r0, #1	; 0x1
  102128:	e0811008 	add	r1, r1, r8
  10212c:	e58c3004 	str	r3, [ip, #4]
  102130:	e5812004 	str	r2, [r1, #4]
  102134:	e0810000 	add	r0, r1, r0
  102138:	e5903004 	ldr	r3, [r0, #4]
  10213c:	e3833001 	orr	r3, r3, #1	; 0x1
  102140:	e5803004 	str	r3, [r0, #4]
  102144:	e2811008 	add	r1, r1, #8	; 0x8
  102148:	e59d0000 	ldr	r0, [sp]
  10214c:	eb000168 	bl	1026f4 <_free_r>
  102150:	eaffffea 	b	102100 <_realloc_r+0x1d0>
  102154:	e3c1c003 	bic	ip, r1, #3	; 0x3
  102158:	e084700c 	add	r7, r4, ip
  10215c:	e15e0007 	cmp	lr, r7
  102160:	caffff9d 	bgt	101fdc <_realloc_r+0xac>
  102164:	e2802008 	add	r2, r0, #8	; 0x8
  102168:	e892000c 	ldmia	r2, {r2, r3}
  10216c:	e1a0c005 	mov	ip, r5
  102170:	e2854008 	add	r4, r5, #8	; 0x8
  102174:	e5832008 	str	r2, [r3, #8]
  102178:	e582300c 	str	r3, [r2, #12]
  10217c:	eaffffd3 	b	1020d0 <_realloc_r+0x1a0>
  102180:	e1a01002 	mov	r1, r2
  102184:	e28dd00c 	add	sp, sp, #12	; 0xc
  102188:	e8bd4ff0 	ldmia	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  10218c:	eafffd82 	b	10179c <_malloc_r>
  102190:	e1a01006 	mov	r1, r6
  102194:	e59d0000 	ldr	r0, [sp]
  102198:	ebfffd7f 	bl	10179c <_malloc_r>
  10219c:	e2506000 	subs	r6, r0, #0	; 0x0
  1021a0:	0a000017 	beq	102204 <_realloc_r+0x2d4>
  1021a4:	e5953004 	ldr	r3, [r5, #4]
  1021a8:	e3c33001 	bic	r3, r3, #1	; 0x1
  1021ac:	e0853003 	add	r3, r5, r3
  1021b0:	e2462008 	sub	r2, r6, #8	; 0x8
  1021b4:	e1520003 	cmp	r2, r3
  1021b8:	0a0000c9 	beq	1024e4 <_realloc_r+0x5b4>
  1021bc:	e2441004 	sub	r1, r4, #4	; 0x4
  1021c0:	e3510024 	cmp	r1, #36	; 0x24
  1021c4:	8a000085 	bhi	1023e0 <_realloc_r+0x4b0>
  1021c8:	e3510013 	cmp	r1, #19	; 0x13
  1021cc:	e1a0c00a 	mov	ip, sl
  1021d0:	e1a0e006 	mov	lr, r6
  1021d4:	8a000057 	bhi	102338 <_realloc_r+0x408>
  1021d8:	e1a0000c 	mov	r0, ip
  1021dc:	e4902004 	ldr	r2, [r0], #4
  1021e0:	e1a0100e 	mov	r1, lr
  1021e4:	e4812004 	str	r2, [r1], #4
  1021e8:	e59c3004 	ldr	r3, [ip, #4]
  1021ec:	e58e3004 	str	r3, [lr, #4]
  1021f0:	e5902004 	ldr	r2, [r0, #4]
  1021f4:	e5812004 	str	r2, [r1, #4]
  1021f8:	e1a0100a 	mov	r1, sl
  1021fc:	e59d0000 	ldr	r0, [sp]
  102200:	eb00013b 	bl	1026f4 <_free_r>
  102204:	e59d0000 	ldr	r0, [sp]
  102208:	ebffff40 	bl	101f10 <__malloc_unlock>
  10220c:	eaffffbe 	b	10210c <_realloc_r+0x1dc>
  102210:	e0849002 	add	r9, r4, r2
  102214:	e159000e 	cmp	r9, lr
  102218:	baffffdc 	blt	102190 <_realloc_r+0x260>
  10221c:	e59d0008 	ldr	r0, [sp, #8]
  102220:	e2444004 	sub	r4, r4, #4	; 0x4
  102224:	e590200c 	ldr	r2, [r0, #12]
  102228:	e5903008 	ldr	r3, [r0, #8]
  10222c:	e3540024 	cmp	r4, #36	; 0x24
  102230:	e1a08000 	mov	r8, r0
  102234:	e5823008 	str	r3, [r2, #8]
  102238:	e583200c 	str	r2, [r3, #12]
  10223c:	e2805008 	add	r5, r0, #8	; 0x8
  102240:	8a00005e 	bhi	1023c0 <_realloc_r+0x490>
  102244:	e3540013 	cmp	r4, #19	; 0x13
  102248:	e1a0c00a 	mov	ip, sl
  10224c:	e1a0e005 	mov	lr, r5
  102250:	9a000011 	bls	10229c <_realloc_r+0x36c>
  102254:	e1a0000a 	mov	r0, sl
  102258:	e4903004 	ldr	r3, [r0], #4
  10225c:	e5883008 	str	r3, [r8, #8]
  102260:	e59a2004 	ldr	r2, [sl, #4]
  102264:	e354001b 	cmp	r4, #27	; 0x1b
  102268:	e588200c 	str	r2, [r8, #12]
  10226c:	e288e010 	add	lr, r8, #16	; 0x10
  102270:	e280c004 	add	ip, r0, #4	; 0x4
  102274:	9a000008 	bls	10229c <_realloc_r+0x36c>
  102278:	e5903004 	ldr	r3, [r0, #4]
  10227c:	e5883010 	str	r3, [r8, #16]
  102280:	e59c2004 	ldr	r2, [ip, #4]
  102284:	e28c3004 	add	r3, ip, #4	; 0x4
  102288:	e3540024 	cmp	r4, #36	; 0x24
  10228c:	e5882014 	str	r2, [r8, #20]
  102290:	e288e018 	add	lr, r8, #24	; 0x18
  102294:	e283c004 	add	ip, r3, #4	; 0x4
  102298:	0a0000a3 	beq	10252c <_realloc_r+0x5fc>
  10229c:	e1a0200c 	mov	r2, ip
  1022a0:	e4921004 	ldr	r1, [r2], #4
  1022a4:	e1a0000e 	mov	r0, lr
  1022a8:	e4801004 	str	r1, [r0], #4
  1022ac:	e59c3004 	ldr	r3, [ip, #4]
  1022b0:	e58e3004 	str	r3, [lr, #4]
  1022b4:	e59dc008 	ldr	ip, [sp, #8]
  1022b8:	e5921004 	ldr	r1, [r2, #4]
  1022bc:	e1a07009 	mov	r7, r9
  1022c0:	e1a04005 	mov	r4, r5
  1022c4:	e5801004 	str	r1, [r0, #4]
  1022c8:	eaffff80 	b	1020d0 <_realloc_r+0x1a0>
  1022cc:	e59d1000 	ldr	r1, [sp]
  1022d0:	e3a0300c 	mov	r3, #12	; 0xc
  1022d4:	e3a06000 	mov	r6, #0	; 0x0
  1022d8:	e5813000 	str	r3, [r1]
  1022dc:	eaffff8a 	b	10210c <_realloc_r+0x1dc>
  1022e0:	e5903004 	ldr	r3, [r0, #4]
  1022e4:	e59d1004 	ldr	r1, [sp, #4]
  1022e8:	e3c3c003 	bic	ip, r3, #3	; 0x3
  1022ec:	e084200c 	add	r2, r4, ip
  1022f0:	e2813010 	add	r3, r1, #16	; 0x10
  1022f4:	e1520003 	cmp	r2, r3
  1022f8:	baffff37 	blt	101fdc <_realloc_r+0xac>
  1022fc:	e0613002 	rsb	r3, r1, r2
  102300:	e3833001 	orr	r3, r3, #1	; 0x1
  102304:	e0851001 	add	r1, r5, r1
  102308:	e5813004 	str	r3, [r1, #4]
  10230c:	e5952004 	ldr	r2, [r5, #4]
  102310:	e59d3004 	ldr	r3, [sp, #4]
  102314:	e2022001 	and	r2, r2, #1	; 0x1
  102318:	e1832002 	orr	r2, r3, r2
  10231c:	e5852004 	str	r2, [r5, #4]
  102320:	e59f223c 	ldr	r2, [pc, #572]	; 102564 <.text+0x2564>
  102324:	e59d0000 	ldr	r0, [sp]
  102328:	e5821008 	str	r1, [r2, #8]
  10232c:	ebfffef7 	bl	101f10 <__malloc_unlock>
  102330:	e2856008 	add	r6, r5, #8	; 0x8
  102334:	eaffff74 	b	10210c <_realloc_r+0x1dc>
  102338:	e1a0400a 	mov	r4, sl
  10233c:	e4943004 	ldr	r3, [r4], #4
  102340:	e1a00006 	mov	r0, r6
  102344:	e4803004 	str	r3, [r0], #4
  102348:	e59a2004 	ldr	r2, [sl, #4]
  10234c:	e351001b 	cmp	r1, #27	; 0x1b
  102350:	e5862004 	str	r2, [r6, #4]
  102354:	e280e004 	add	lr, r0, #4	; 0x4
  102358:	e284c004 	add	ip, r4, #4	; 0x4
  10235c:	9affff9d 	bls	1021d8 <_realloc_r+0x2a8>
  102360:	e5943004 	ldr	r3, [r4, #4]
  102364:	e5803004 	str	r3, [r0, #4]
  102368:	e59c2004 	ldr	r2, [ip, #4]
  10236c:	e3510024 	cmp	r1, #36	; 0x24
  102370:	e28c3004 	add	r3, ip, #4	; 0x4
  102374:	e28e1004 	add	r1, lr, #4	; 0x4
  102378:	e58e2004 	str	r2, [lr, #4]
  10237c:	e283c004 	add	ip, r3, #4	; 0x4
  102380:	e281e004 	add	lr, r1, #4	; 0x4
  102384:	1affff93 	bne	1021d8 <_realloc_r+0x2a8>
  102388:	e5933004 	ldr	r3, [r3, #4]
  10238c:	e5813004 	str	r3, [r1, #4]
  102390:	e59c2004 	ldr	r2, [ip, #4]
  102394:	e28cc008 	add	ip, ip, #8	; 0x8
  102398:	e58e2004 	str	r2, [lr, #4]
  10239c:	e28ee008 	add	lr, lr, #8	; 0x8
  1023a0:	eaffff8c 	b	1021d8 <_realloc_r+0x2a8>
  1023a4:	e1a02004 	mov	r2, r4
  1023a8:	e1a0100a 	mov	r1, sl
  1023ac:	e1a00005 	mov	r0, r5
  1023b0:	eb000177 	bl	102994 <memmove>
  1023b4:	e1a04005 	mov	r4, r5
  1023b8:	e1a0c008 	mov	ip, r8
  1023bc:	eaffff43 	b	1020d0 <_realloc_r+0x1a0>
  1023c0:	e1a02004 	mov	r2, r4
  1023c4:	e1a0100a 	mov	r1, sl
  1023c8:	e1a00005 	mov	r0, r5
  1023cc:	eb000170 	bl	102994 <memmove>
  1023d0:	e1a07009 	mov	r7, r9
  1023d4:	e1a04005 	mov	r4, r5
  1023d8:	e1a0c008 	mov	ip, r8
  1023dc:	eaffff3b 	b	1020d0 <_realloc_r+0x1a0>
  1023e0:	e1a02001 	mov	r2, r1
  1023e4:	e1a0100a 	mov	r1, sl
  1023e8:	eb000169 	bl	102994 <memmove>
  1023ec:	eaffff81 	b	1021f8 <_realloc_r+0x2c8>
  1023f0:	e59d0004 	ldr	r0, [sp, #4]
  1023f4:	e0849002 	add	r9, r4, r2
  1023f8:	e08c7009 	add	r7, ip, r9
  1023fc:	e2803010 	add	r3, r0, #16	; 0x10
  102400:	e1570003 	cmp	r7, r3
  102404:	baffff82 	blt	102214 <_realloc_r+0x2e4>
  102408:	e59d1008 	ldr	r1, [sp, #8]
  10240c:	e2444004 	sub	r4, r4, #4	; 0x4
  102410:	e591200c 	ldr	r2, [r1, #12]
  102414:	e5913008 	ldr	r3, [r1, #8]
  102418:	e3540024 	cmp	r4, #36	; 0x24
  10241c:	e5823008 	str	r3, [r2, #8]
  102420:	e583200c 	str	r2, [r3, #12]
  102424:	e2816008 	add	r6, r1, #8	; 0x8
  102428:	8a000033 	bhi	1024fc <_realloc_r+0x5cc>
  10242c:	e3540013 	cmp	r4, #19	; 0x13
  102430:	e1a0c00a 	mov	ip, sl
  102434:	e1a0e006 	mov	lr, r6
  102438:	9a000011 	bls	102484 <_realloc_r+0x554>
  10243c:	e1a0000a 	mov	r0, sl
  102440:	e4903004 	ldr	r3, [r0], #4
  102444:	e5813008 	str	r3, [r1, #8]
  102448:	e59a2004 	ldr	r2, [sl, #4]
  10244c:	e354001b 	cmp	r4, #27	; 0x1b
  102450:	e581200c 	str	r2, [r1, #12]
  102454:	e281e010 	add	lr, r1, #16	; 0x10
  102458:	e280c004 	add	ip, r0, #4	; 0x4
  10245c:	9a000008 	bls	102484 <_realloc_r+0x554>
  102460:	e5903004 	ldr	r3, [r0, #4]
  102464:	e5813010 	str	r3, [r1, #16]
  102468:	e59c2004 	ldr	r2, [ip, #4]
  10246c:	e28c3004 	add	r3, ip, #4	; 0x4
  102470:	e3540024 	cmp	r4, #36	; 0x24
  102474:	e5812014 	str	r2, [r1, #20]
  102478:	e281e018 	add	lr, r1, #24	; 0x18
  10247c:	e283c004 	add	ip, r3, #4	; 0x4
  102480:	0a000030 	beq	102548 <_realloc_r+0x618>
  102484:	e1a0000c 	mov	r0, ip
  102488:	e4902004 	ldr	r2, [r0], #4
  10248c:	e1a0100e 	mov	r1, lr
  102490:	e4812004 	str	r2, [r1], #4
  102494:	e59c3004 	ldr	r3, [ip, #4]
  102498:	e58e3004 	str	r3, [lr, #4]
  10249c:	e5902004 	ldr	r2, [r0, #4]
  1024a0:	e5812004 	str	r2, [r1, #4]
  1024a4:	e59d2004 	ldr	r2, [sp, #4]
  1024a8:	e59d0008 	ldr	r0, [sp, #8]
  1024ac:	e0623007 	rsb	r3, r2, r7
  1024b0:	e0801002 	add	r1, r0, r2
  1024b4:	e3833001 	orr	r3, r3, #1	; 0x1
  1024b8:	e5813004 	str	r3, [r1, #4]
  1024bc:	e5902004 	ldr	r2, [r0, #4]
  1024c0:	e59d3004 	ldr	r3, [sp, #4]
  1024c4:	e2022001 	and	r2, r2, #1	; 0x1
  1024c8:	e1832002 	orr	r2, r3, r2
  1024cc:	e5802004 	str	r2, [r0, #4]
  1024d0:	e59f208c 	ldr	r2, [pc, #140]	; 102564 <.text+0x2564>
  1024d4:	e59d0000 	ldr	r0, [sp]
  1024d8:	e5821008 	str	r1, [r2, #8]
  1024dc:	ebfffe8b 	bl	101f10 <__malloc_unlock>
  1024e0:	eaffff09 	b	10210c <_realloc_r+0x1dc>
  1024e4:	e5923004 	ldr	r3, [r2, #4]
  1024e8:	e3c33003 	bic	r3, r3, #3	; 0x3
  1024ec:	e0847003 	add	r7, r4, r3
  1024f0:	e1a0c005 	mov	ip, r5
  1024f4:	e2854008 	add	r4, r5, #8	; 0x8
  1024f8:	eafffef4 	b	1020d0 <_realloc_r+0x1a0>
  1024fc:	e1a0100a 	mov	r1, sl
  102500:	e1a02004 	mov	r2, r4
  102504:	e1a00006 	mov	r0, r6
  102508:	eb000121 	bl	102994 <memmove>
  10250c:	eaffffe4 	b	1024a4 <_realloc_r+0x574>
  102510:	e5933004 	ldr	r3, [r3, #4]
  102514:	e5883018 	str	r3, [r8, #24]
  102518:	e59c2004 	ldr	r2, [ip, #4]
  10251c:	e288e020 	add	lr, r8, #32	; 0x20
  102520:	e28cc008 	add	ip, ip, #8	; 0x8
  102524:	e588201c 	str	r2, [r8, #28]
  102528:	eafffede 	b	1020a8 <_realloc_r+0x178>
  10252c:	e5933004 	ldr	r3, [r3, #4]
  102530:	e5883018 	str	r3, [r8, #24]
  102534:	e59c2004 	ldr	r2, [ip, #4]
  102538:	e288e020 	add	lr, r8, #32	; 0x20
  10253c:	e28cc008 	add	ip, ip, #8	; 0x8
  102540:	e588201c 	str	r2, [r8, #28]
  102544:	eaffff54 	b	10229c <_realloc_r+0x36c>
  102548:	e5933004 	ldr	r3, [r3, #4]
  10254c:	e5813018 	str	r3, [r1, #24]
  102550:	e59c2004 	ldr	r2, [ip, #4]
  102554:	e281e020 	add	lr, r1, #32	; 0x20
  102558:	e28cc008 	add	ip, ip, #8	; 0x8
  10255c:	e581201c 	str	r2, [r1, #28]
  102560:	eaffffc7 	b	102484 <_realloc_r+0x554>
  102564:	00200010 	eoreq	r0, r0, r0, lsl r0

00102568 <strlen>:
  102568:	e3100003 	tst	r0, #3	; 0x3
  10256c:	e1a01000 	mov	r1, r0
  102570:	1a000018 	bne	1025d8 <strlen+0x70>
  102574:	e5902000 	ldr	r2, [r0]
  102578:	e28234ff 	add	r3, r2, #-16777216	; 0xff000000
  10257c:	e2433801 	sub	r3, r3, #65536	; 0x10000
  102580:	e2433c01 	sub	r3, r3, #256	; 0x100
  102584:	e2433001 	sub	r3, r3, #1	; 0x1
  102588:	e3c3347f 	bic	r3, r3, #2130706432	; 0x7f000000
  10258c:	e3c3387f 	bic	r3, r3, #8323072	; 0x7f0000
  102590:	e3c33c7f 	bic	r3, r3, #32512	; 0x7f00
  102594:	e3c3307f 	bic	r3, r3, #127	; 0x7f
  102598:	e1d32002 	bics	r2, r3, r2
  10259c:	e1a02000 	mov	r2, r0
  1025a0:	1a00000b 	bne	1025d4 <strlen+0x6c>
  1025a4:	e5b02004 	ldr	r2, [r0, #4]!
  1025a8:	e28234ff 	add	r3, r2, #-16777216	; 0xff000000
  1025ac:	e2433801 	sub	r3, r3, #65536	; 0x10000
  1025b0:	e2433c01 	sub	r3, r3, #256	; 0x100
  1025b4:	e2433001 	sub	r3, r3, #1	; 0x1
  1025b8:	e3c3347f 	bic	r3, r3, #2130706432	; 0x7f000000
  1025bc:	e3c3387f 	bic	r3, r3, #8323072	; 0x7f0000
  1025c0:	e3c33c7f 	bic	r3, r3, #32512	; 0x7f00
  1025c4:	e3c3307f 	bic	r3, r3, #127	; 0x7f
  1025c8:	e1d32002 	bics	r2, r3, r2
  1025cc:	0afffff4 	beq	1025a4 <strlen+0x3c>
  1025d0:	e1a02000 	mov	r2, r0
  1025d4:	e1a00002 	mov	r0, r2
  1025d8:	e5d03000 	ldrb	r3, [r0]
  1025dc:	e3530000 	cmp	r3, #0	; 0x0
  1025e0:	0a000002 	beq	1025f0 <strlen+0x88>
  1025e4:	e5f03001 	ldrb	r3, [r0, #1]!
  1025e8:	e3530000 	cmp	r3, #0	; 0x0
  1025ec:	1afffffc 	bne	1025e4 <strlen+0x7c>
  1025f0:	e0610000 	rsb	r0, r1, r0
  1025f4:	e12fff1e 	bx	lr

001025f8 <_malloc_trim_r>:
  1025f8:	e92d40f0 	stmdb	sp!, {r4, r5, r6, r7, lr}
  1025fc:	e59f70e4 	ldr	r7, [pc, #228]	; 1026e8 <.text+0x26e8>
  102600:	e1a04001 	mov	r4, r1
  102604:	e1a05000 	mov	r5, r0
  102608:	ebfffe3f 	bl	101f0c <__malloc_lock>
  10260c:	e5973008 	ldr	r3, [r7, #8]
  102610:	e5932004 	ldr	r2, [r3, #4]
  102614:	e3c26003 	bic	r6, r2, #3	; 0x3
  102618:	e0644006 	rsb	r4, r4, r6
  10261c:	e2844efe 	add	r4, r4, #4064	; 0xfe0
  102620:	e284400f 	add	r4, r4, #15	; 0xf
  102624:	e1a04624 	mov	r4, r4, lsr #12
  102628:	e2444001 	sub	r4, r4, #1	; 0x1
  10262c:	e1a04604 	mov	r4, r4, lsl #12
  102630:	e3540a01 	cmp	r4, #4096	; 0x1000
  102634:	e3a01000 	mov	r1, #0	; 0x0
  102638:	e1a00005 	mov	r0, r5
  10263c:	ba000006 	blt	10265c <_malloc_trim_r+0x64>
  102640:	ebfff685 	bl	10005c <_sbrk_r>
  102644:	e5973008 	ldr	r3, [r7, #8]
  102648:	e0863003 	add	r3, r6, r3
  10264c:	e1500003 	cmp	r0, r3
  102650:	e2641000 	rsb	r1, r4, #0	; 0x0
  102654:	e1a00005 	mov	r0, r5
  102658:	0a000002 	beq	102668 <_malloc_trim_r+0x70>
  10265c:	ebfffe2b 	bl	101f10 <__malloc_unlock>
  102660:	e3a00000 	mov	r0, #0	; 0x0
  102664:	e8bd80f0 	ldmia	sp!, {r4, r5, r6, r7, pc}
  102668:	ebfff67b 	bl	10005c <_sbrk_r>
  10266c:	e0643006 	rsb	r3, r4, r6
  102670:	e3700001 	cmn	r0, #1	; 0x1
  102674:	e3a01000 	mov	r1, #0	; 0x0
  102678:	e59fe06c 	ldr	lr, [pc, #108]	; 1026ec <.text+0x26ec>
  10267c:	e383c001 	orr	ip, r3, #1	; 0x1
  102680:	e1a00005 	mov	r0, r5
  102684:	0a000008 	beq	1026ac <_malloc_trim_r+0xb4>
  102688:	e59e3000 	ldr	r3, [lr]
  10268c:	e5972008 	ldr	r2, [r7, #8]
  102690:	e0643003 	rsb	r3, r4, r3
  102694:	e1a00005 	mov	r0, r5
  102698:	e582c004 	str	ip, [r2, #4]
  10269c:	e58e3000 	str	r3, [lr]
  1026a0:	ebfffe1a 	bl	101f10 <__malloc_unlock>
  1026a4:	e3a00001 	mov	r0, #1	; 0x1
  1026a8:	e8bd80f0 	ldmia	sp!, {r4, r5, r6, r7, pc}
  1026ac:	ebfff66a 	bl	10005c <_sbrk_r>
  1026b0:	e5971008 	ldr	r1, [r7, #8]
  1026b4:	e1a0e000 	mov	lr, r0
  1026b8:	e061300e 	rsb	r3, r1, lr
  1026bc:	e353000f 	cmp	r3, #15	; 0xf
  1026c0:	e1a00005 	mov	r0, r5
  1026c4:	e383c001 	orr	ip, r3, #1	; 0x1
  1026c8:	daffffe3 	ble	10265c <_malloc_trim_r+0x64>
  1026cc:	e59f301c 	ldr	r3, [pc, #28]	; 1026f0 <.text+0x26f0>
  1026d0:	e5932000 	ldr	r2, [r3]
  1026d4:	e59f3010 	ldr	r3, [pc, #16]	; 1026ec <.text+0x26ec>
  1026d8:	e062200e 	rsb	r2, r2, lr
  1026dc:	e5832000 	str	r2, [r3]
  1026e0:	e581c004 	str	ip, [r1, #4]
  1026e4:	eaffffdc 	b	10265c <_malloc_trim_r+0x64>
  1026e8:	00200010 	eoreq	r0, r0, r0, lsl r0
  1026ec:	002009e0 	eoreq	r0, r0, r0, ror #19
  1026f0:	0020041c 	eoreq	r0, r0, ip, lsl r4

001026f4 <_free_r>:
  1026f4:	e92d45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
  1026f8:	e2514000 	subs	r4, r1, #0	; 0x0
  1026fc:	e1a08000 	mov	r8, r0
  102700:	08bd85f0 	ldmeqia	sp!, {r4, r5, r6, r7, r8, sl, pc}
  102704:	ebfffe00 	bl	101f0c <__malloc_lock>
  102708:	e244e008 	sub	lr, r4, #8	; 0x8
  10270c:	e59e0004 	ldr	r0, [lr, #4]
  102710:	e59f726c 	ldr	r7, [pc, #620]	; 102984 <.text+0x2984>
  102714:	e3c01001 	bic	r1, r0, #1	; 0x1
  102718:	e08ec001 	add	ip, lr, r1
  10271c:	e5973008 	ldr	r3, [r7, #8]
  102720:	e59c2004 	ldr	r2, [ip, #4]
  102724:	e15c0003 	cmp	ip, r3
  102728:	e3c25003 	bic	r5, r2, #3	; 0x3
  10272c:	e1a0a007 	mov	sl, r7
  102730:	0a000077 	beq	102914 <_free_r+0x220>
  102734:	e2106001 	ands	r6, r0, #1	; 0x1
  102738:	e58c5004 	str	r5, [ip, #4]
  10273c:	13a00000 	movne	r0, #0	; 0x0
  102740:	0a000018 	beq	1027a8 <_free_r+0xb4>
  102744:	e08c3005 	add	r3, ip, r5
  102748:	e5932004 	ldr	r2, [r3, #4]
  10274c:	e3120001 	tst	r2, #1	; 0x1
  102750:	0a000007 	beq	102774 <_free_r+0x80>
  102754:	e3813001 	orr	r3, r1, #1	; 0x1
  102758:	e3500000 	cmp	r0, #0	; 0x0
  10275c:	e58e3004 	str	r3, [lr, #4]
  102760:	e781100e 	str	r1, [r1, lr]
  102764:	0a00001f 	beq	1027e8 <_free_r+0xf4>
  102768:	e1a00008 	mov	r0, r8
  10276c:	e8bd45f0 	ldmia	sp!, {r4, r5, r6, r7, r8, sl, lr}
  102770:	eafffde6 	b	101f10 <__malloc_unlock>
  102774:	e3500000 	cmp	r0, #0	; 0x0
  102778:	e0811005 	add	r1, r1, r5
  10277c:	159c2008 	ldrne	r2, [ip, #8]
  102780:	0a00004a 	beq	1028b0 <_free_r+0x1bc>
  102784:	e59c300c 	ldr	r3, [ip, #12]
  102788:	e3500000 	cmp	r0, #0	; 0x0
  10278c:	e5832008 	str	r2, [r3, #8]
  102790:	e582300c 	str	r3, [r2, #12]
  102794:	e3813001 	orr	r3, r1, #1	; 0x1
  102798:	e58e3004 	str	r3, [lr, #4]
  10279c:	e781100e 	str	r1, [r1, lr]
  1027a0:	1afffff0 	bne	102768 <_free_r+0x74>
  1027a4:	ea00000f 	b	1027e8 <_free_r+0xf4>
  1027a8:	e5142008 	ldr	r2, [r4, #-8]
  1027ac:	e062e00e 	rsb	lr, r2, lr
  1027b0:	e59e0008 	ldr	r0, [lr, #8]
  1027b4:	e2873008 	add	r3, r7, #8	; 0x8
  1027b8:	e1500003 	cmp	r0, r3
  1027bc:	159e300c 	ldrne	r3, [lr, #12]
  1027c0:	15830008 	strne	r0, [r3, #8]
  1027c4:	1580300c 	strne	r3, [r0, #12]
  1027c8:	e08c3005 	add	r3, ip, r5
  1027cc:	e0811002 	add	r1, r1, r2
  1027d0:	e5932004 	ldr	r2, [r3, #4]
  1027d4:	03a00001 	moveq	r0, #1	; 0x1
  1027d8:	11a00006 	movne	r0, r6
  1027dc:	e3120001 	tst	r2, #1	; 0x1
  1027e0:	1affffdb 	bne	102754 <_free_r+0x60>
  1027e4:	eaffffe2 	b	102774 <_free_r+0x80>
  1027e8:	e3510c02 	cmp	r1, #512	; 0x200
  1027ec:	3a00003b 	bcc	1028e0 <_free_r+0x1ec>
  1027f0:	e1b024a1 	movs	r2, r1, lsr #9
  1027f4:	01a021a1 	moveq	r2, r1, lsr #3
  1027f8:	01a03182 	moveq	r3, r2, lsl #3
  1027fc:	0a00001a 	beq	10286c <_free_r+0x178>
  102800:	e3520004 	cmp	r2, #4	; 0x4
  102804:	91a03321 	movls	r3, r1, lsr #6
  102808:	92832038 	addls	r2, r3, #56	; 0x38
  10280c:	91a03182 	movls	r3, r2, lsl #3
  102810:	9a000015 	bls	10286c <_free_r+0x178>
  102814:	e3520014 	cmp	r2, #20	; 0x14
  102818:	9282205b 	addls	r2, r2, #91	; 0x5b
  10281c:	91a03182 	movls	r3, r2, lsl #3
  102820:	9a000011 	bls	10286c <_free_r+0x178>
  102824:	e3520054 	cmp	r2, #84	; 0x54
  102828:	91a03621 	movls	r3, r1, lsr #12
  10282c:	9283206e 	addls	r2, r3, #110	; 0x6e
  102830:	91a03182 	movls	r3, r2, lsl #3
  102834:	9a00000c 	bls	10286c <_free_r+0x178>
  102838:	e3520f55 	cmp	r2, #340	; 0x154
  10283c:	91a037a1 	movls	r3, r1, lsr #15
  102840:	92832077 	addls	r2, r3, #119	; 0x77
  102844:	91a03182 	movls	r3, r2, lsl #3
  102848:	9a000007 	bls	10286c <_free_r+0x178>
  10284c:	e3a03e55 	mov	r3, #1360	; 0x550
  102850:	e2833004 	add	r3, r3, #4	; 0x4
  102854:	e1520003 	cmp	r2, r3
  102858:	91a03921 	movls	r3, r1, lsr #18
  10285c:	9283207c 	addls	r2, r3, #124	; 0x7c
  102860:	83a0207e 	movhi	r2, #126	; 0x7e
  102864:	82433f59 	subhi	r3, r3, #356	; 0x164
  102868:	91a03182 	movls	r3, r2, lsl #3
  10286c:	e083c00a 	add	ip, r3, sl
  102870:	e59c0008 	ldr	r0, [ip, #8]
  102874:	e15c0000 	cmp	ip, r0
  102878:	0a00003b 	beq	10296c <_free_r+0x278>
  10287c:	e5903004 	ldr	r3, [r0, #4]
  102880:	e3c33003 	bic	r3, r3, #3	; 0x3
  102884:	e1510003 	cmp	r1, r3
  102888:	2a000002 	bcs	102898 <_free_r+0x1a4>
  10288c:	e5900008 	ldr	r0, [r0, #8]
  102890:	e15c0000 	cmp	ip, r0
  102894:	1afffff8 	bne	10287c <_free_r+0x188>
  102898:	e590c00c 	ldr	ip, [r0, #12]
  10289c:	e58ec00c 	str	ip, [lr, #12]
  1028a0:	e58e0008 	str	r0, [lr, #8]
  1028a4:	e580e00c 	str	lr, [r0, #12]
  1028a8:	e58ce008 	str	lr, [ip, #8]
  1028ac:	eaffffad 	b	102768 <_free_r+0x74>
  1028b0:	e59c2008 	ldr	r2, [ip, #8]
  1028b4:	e59f30cc 	ldr	r3, [pc, #204]	; 102988 <.text+0x2988>
  1028b8:	e1520003 	cmp	r2, r3
  1028bc:	1affffb0 	bne	102784 <_free_r+0x90>
  1028c0:	e3813001 	orr	r3, r1, #1	; 0x1
  1028c4:	e582e00c 	str	lr, [r2, #12]
  1028c8:	e582e008 	str	lr, [r2, #8]
  1028cc:	e781100e 	str	r1, [r1, lr]
  1028d0:	e58e3004 	str	r3, [lr, #4]
  1028d4:	e58e2008 	str	r2, [lr, #8]
  1028d8:	e58e200c 	str	r2, [lr, #12]
  1028dc:	eaffffa1 	b	102768 <_free_r+0x74>
  1028e0:	e1a011a1 	mov	r1, r1, lsr #3
  1028e4:	e5972004 	ldr	r2, [r7, #4]
  1028e8:	e1a00121 	mov	r0, r1, lsr #2
  1028ec:	e3a03001 	mov	r3, #1	; 0x1
  1028f0:	e1822013 	orr	r2, r2, r3, lsl r0
  1028f4:	e08a1181 	add	r1, sl, r1, lsl #3
  1028f8:	e5913008 	ldr	r3, [r1, #8]
  1028fc:	e58e100c 	str	r1, [lr, #12]
  102900:	e58e3008 	str	r3, [lr, #8]
  102904:	e5872004 	str	r2, [r7, #4]
  102908:	e583e00c 	str	lr, [r3, #12]
  10290c:	e581e008 	str	lr, [r1, #8]
  102910:	eaffff94 	b	102768 <_free_r+0x74>
  102914:	e3100001 	tst	r0, #1	; 0x1
  102918:	e0810005 	add	r0, r1, r5
  10291c:	1a000006 	bne	10293c <_free_r+0x248>
  102920:	e5141008 	ldr	r1, [r4, #-8]
  102924:	e061e00e 	rsb	lr, r1, lr
  102928:	e59e200c 	ldr	r2, [lr, #12]
  10292c:	e59e3008 	ldr	r3, [lr, #8]
  102930:	e5823008 	str	r3, [r2, #8]
  102934:	e583200c 	str	r2, [r3, #12]
  102938:	e0800001 	add	r0, r0, r1
  10293c:	e59f3048 	ldr	r3, [pc, #72]	; 10298c <.text+0x298c>
  102940:	e5932000 	ldr	r2, [r3]
  102944:	e3803001 	orr	r3, r0, #1	; 0x1
  102948:	e1500002 	cmp	r0, r2
  10294c:	e587e008 	str	lr, [r7, #8]
  102950:	e58e3004 	str	r3, [lr, #4]
  102954:	3affff83 	bcc	102768 <_free_r+0x74>
  102958:	e59f3030 	ldr	r3, [pc, #48]	; 102990 <.text+0x2990>
  10295c:	e1a00008 	mov	r0, r8
  102960:	e5931000 	ldr	r1, [r3]
  102964:	ebffff23 	bl	1025f8 <_malloc_trim_r>
  102968:	eaffff7e 	b	102768 <_free_r+0x74>
  10296c:	e5973004 	ldr	r3, [r7, #4]
  102970:	e1a01122 	mov	r1, r2, lsr #2
  102974:	e3a02001 	mov	r2, #1	; 0x1
  102978:	e1833112 	orr	r3, r3, r2, lsl r1
  10297c:	e5873004 	str	r3, [r7, #4]
  102980:	eaffffc5 	b	10289c <_free_r+0x1a8>
  102984:	00200010 	eoreq	r0, r0, r0, lsl r0
  102988:	00200018 	eoreq	r0, r0, r8, lsl r0
  10298c:	00200418 	eoreq	r0, r0, r8, lsl r4
  102990:	002009d4 	ldreqd	r0, [r0], -r4

00102994 <memmove>:
  102994:	e1500001 	cmp	r0, r1
  102998:	e92d4010 	stmdb	sp!, {r4, lr}
  10299c:	e1a0c000 	mov	ip, r0
  1029a0:	e1a04001 	mov	r4, r1
  1029a4:	e1a0e002 	mov	lr, r2
  1029a8:	9a000010 	bls	1029f0 <memmove+0x5c>
  1029ac:	e0813002 	add	r3, r1, r2
  1029b0:	e1500003 	cmp	r0, r3
  1029b4:	2a00000d 	bcs	1029f0 <memmove+0x5c>
  1029b8:	e3520000 	cmp	r2, #0	; 0x0
  1029bc:	08bd8010 	ldmeqia	sp!, {r4, pc}
  1029c0:	e0801002 	add	r1, r0, r2
  1029c4:	e1a0c003 	mov	ip, r3
  1029c8:	e0622001 	rsb	r2, r2, r1
  1029cc:	e57c3001 	ldrb	r3, [ip, #-1]!
  1029d0:	e5613001 	strb	r3, [r1, #-1]!
  1029d4:	e1520001 	cmp	r2, r1
  1029d8:	08bd8010 	ldmeqia	sp!, {r4, pc}
  1029dc:	e57c3001 	ldrb	r3, [ip, #-1]!
  1029e0:	e5613001 	strb	r3, [r1, #-1]!
  1029e4:	e1520001 	cmp	r2, r1
  1029e8:	1afffff7 	bne	1029cc <memmove+0x38>
  1029ec:	e8bd8010 	ldmia	sp!, {r4, pc}
  1029f0:	e35e000f 	cmp	lr, #15	; 0xf
  1029f4:	8a000008 	bhi	102a1c <memmove+0x88>
  1029f8:	e35e0000 	cmp	lr, #0	; 0x0
  1029fc:	08bd8010 	ldmeqia	sp!, {r4, pc}
  102a00:	e3a02000 	mov	r2, #0	; 0x0
  102a04:	e4d13001 	ldrb	r3, [r1], #1
  102a08:	e7c2300c 	strb	r3, [r2, ip]
  102a0c:	e2822001 	add	r2, r2, #1	; 0x1
  102a10:	e152000e 	cmp	r2, lr
  102a14:	1afffffa 	bne	102a04 <memmove+0x70>
  102a18:	e8bd8010 	ldmia	sp!, {r4, pc}
  102a1c:	e1843000 	orr	r3, r4, r0
  102a20:	e3130003 	tst	r3, #3	; 0x3
  102a24:	1afffff3 	bne	1029f8 <memmove+0x64>
  102a28:	e1a01004 	mov	r1, r4
  102a2c:	e1a0c000 	mov	ip, r0
  102a30:	e5913000 	ldr	r3, [r1]
  102a34:	e58c3000 	str	r3, [ip]
  102a38:	e5912004 	ldr	r2, [r1, #4]
  102a3c:	e58c2004 	str	r2, [ip, #4]
  102a40:	e5913008 	ldr	r3, [r1, #8]
  102a44:	e58c3008 	str	r3, [ip, #8]
  102a48:	e24ee010 	sub	lr, lr, #16	; 0x10
  102a4c:	e591300c 	ldr	r3, [r1, #12]
  102a50:	e35e000f 	cmp	lr, #15	; 0xf
  102a54:	e58c300c 	str	r3, [ip, #12]
  102a58:	e2811010 	add	r1, r1, #16	; 0x10
  102a5c:	e28cc010 	add	ip, ip, #16	; 0x10
  102a60:	8afffff2 	bhi	102a30 <memmove+0x9c>
  102a64:	e35e0003 	cmp	lr, #3	; 0x3
  102a68:	9affffe2 	bls	1029f8 <memmove+0x64>
  102a6c:	e24ee004 	sub	lr, lr, #4	; 0x4
  102a70:	e4913004 	ldr	r3, [r1], #4
  102a74:	e35e0003 	cmp	lr, #3	; 0x3
  102a78:	e48c3004 	str	r3, [ip], #4
  102a7c:	8afffffa 	bhi	102a6c <memmove+0xd8>
  102a80:	e35e0000 	cmp	lr, #0	; 0x0
  102a84:	1affffdd 	bne	102a00 <memmove+0x6c>
  102a88:	e8bd8010 	ldmia	sp!, {r4, pc}
Déassemblage de la section .data:

00200000 <_data>:
  200000:	fffff400 	undefined instruction 0xfffff400

00200004 <pUSART>:
  200004:	fffc0000                                ....

00200008 <pPIOA>:
  200008:	fffff400                                ....

0020000c <pSPI>:
  20000c:	fffe0000                                ....

00200010 <__malloc_av_>:
	...
  200018:	00200010 00200010 00200018 00200018     .. ... ... ... .
  200028:	00200020 00200020 00200028 00200028      . . . .(. .(. .
  200038:	00200030 00200030 00200038 00200038     0. .0. .8. .8. .
  200048:	00200040 00200040 00200048 00200048     @. .@. .H. .H. .
  200058:	00200050 00200050 00200058 00200058     P. .P. .X. .X. .
  200068:	00200060 00200060 00200068 00200068     `. .`. .h. .h. .
  200078:	00200070 00200070 00200078 00200078     p. .p. .x. .x. .
  200088:	00200080 00200080 00200088 00200088     .. ... ... ... .
  200098:	00200090 00200090 00200098 00200098     .. ... ... ... .
  2000a8:	002000a0 002000a0 002000a8 002000a8     .. ... ... ... .
  2000b8:	002000b0 002000b0 002000b8 002000b8     .. ... ... ... .
  2000c8:	002000c0 002000c0 002000c8 002000c8     .. ... ... ... .
  2000d8:	002000d0 002000d0 002000d8 002000d8     .. ... ... ... .
  2000e8:	002000e0 002000e0 002000e8 002000e8     .. ... ... ... .
  2000f8:	002000f0 002000f0 002000f8 002000f8     .. ... ... ... .
  200108:	00200100 00200100 00200108 00200108     .. ... ... ... .
  200118:	00200110 00200110 00200118 00200118     .. ... ... ... .
  200128:	00200120 00200120 00200128 00200128      . . . .(. .(. .
  200138:	00200130 00200130 00200138 00200138     0. .0. .8. .8. .
  200148:	00200140 00200140 00200148 00200148     @. .@. .H. .H. .
  200158:	00200150 00200150 00200158 00200158     P. .P. .X. .X. .
  200168:	00200160 00200160 00200168 00200168     `. .`. .h. .h. .
  200178:	00200170 00200170 00200178 00200178     p. .p. .x. .x. .
  200188:	00200180 00200180 00200188 00200188     .. ... ... ... .
  200198:	00200190 00200190 00200198 00200198     .. ... ... ... .
  2001a8:	002001a0 002001a0 002001a8 002001a8     .. ... ... ... .
  2001b8:	002001b0 002001b0 002001b8 002001b8     .. ... ... ... .
  2001c8:	002001c0 002001c0 002001c8 002001c8     .. ... ... ... .
  2001d8:	002001d0 002001d0 002001d8 002001d8     .. ... ... ... .
  2001e8:	002001e0 002001e0 002001e8 002001e8     .. ... ... ... .
  2001f8:	002001f0 002001f0 002001f8 002001f8     .. ... ... ... .
  200208:	00200200 00200200 00200208 00200208     .. ... ... ... .
  200218:	00200210 00200210 00200218 00200218     .. ... ... ... .
  200228:	00200220 00200220 00200228 00200228      . . . .(. .(. .
  200238:	00200230 00200230 00200238 00200238     0. .0. .8. .8. .
  200248:	00200240 00200240 00200248 00200248     @. .@. .H. .H. .
  200258:	00200250 00200250 00200258 00200258     P. .P. .X. .X. .
  200268:	00200260 00200260 00200268 00200268     `. .`. .h. .h. .
  200278:	00200270 00200270 00200278 00200278     p. .p. .x. .x. .
  200288:	00200280 00200280 00200288 00200288     .. ... ... ... .
  200298:	00200290 00200290 00200298 00200298     .. ... ... ... .
  2002a8:	002002a0 002002a0 002002a8 002002a8     .. ... ... ... .
  2002b8:	002002b0 002002b0 002002b8 002002b8     .. ... ... ... .
  2002c8:	002002c0 002002c0 002002c8 002002c8     .. ... ... ... .
  2002d8:	002002d0 002002d0 002002d8 002002d8     .. ... ... ... .
  2002e8:	002002e0 002002e0 002002e8 002002e8     .. ... ... ... .
  2002f8:	002002f0 002002f0 002002f8 002002f8     .. ... ... ... .
  200308:	00200300 00200300 00200308 00200308     .. ... ... ... .
  200318:	00200310 00200310 00200318 00200318     .. ... ... ... .
  200328:	00200320 00200320 00200328 00200328      . . . .(. .(. .
  200338:	00200330 00200330 00200338 00200338     0. .0. .8. .8. .
  200348:	00200340 00200340 00200348 00200348     @. .@. .H. .H. .
  200358:	00200350 00200350 00200358 00200358     P. .P. .X. .X. .
  200368:	00200360 00200360 00200368 00200368     `. .`. .h. .h. .
  200378:	00200370 00200370 00200378 00200378     p. .p. .x. .x. .
  200388:	00200380 00200380 00200388 00200388     .. ... ... ... .
  200398:	00200390 00200390 00200398 00200398     .. ... ... ... .
  2003a8:	002003a0 002003a0 002003a8 002003a8     .. ... ... ... .
  2003b8:	002003b0 002003b0 002003b8 002003b8     .. ... ... ... .
  2003c8:	002003c0 002003c0 002003c8 002003c8     .. ... ... ... .
  2003d8:	002003d0 002003d0 002003d8 002003d8     .. ... ... ... .
  2003e8:	002003e0 002003e0 002003e8 002003e8     .. ... ... ... .
  2003f8:	002003f0 002003f0 002003f8 002003f8     .. ... ... ... .
  200408:	00200400 00200400 00200408 00200408     .. ... ... ... .

00200418 <__malloc_trim_threshold>:
  200418:	00020000                                ....

0020041c <__malloc_sbrk_base>:
  20041c:	ffffffff                                ....

00200420 <_impure_ptr>:
  200420:	00200424                                $. .

00200424 <impure_data>:
  200424:	00000000 00200710 0020076c 002007c8     ...... .l. ... .
	...
  200458:	00102aa4 00000000 00000000 00000000     .*..............
	...
  2004c8:	00000001 00000000 abcd330e e66d1234     .........3..4.m.
  2004d8:	0005deec 0000000b 00000000 00000000     ................
	...

00200824 <system_int>:
  200824:	e3a034a6 	mov	r3, #-1509949440	; 0xa6000000
  200828:	e1a03ac3 	mov	r3, r3, asr #21
  20082c:	e58b3000 	str	r3, [fp]
  200830:	e24ee004 	sub	lr, lr, #4	; 0x4
  200834:	e92d5fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
  200838:	e14f1000 	mrs	r1, SPSR
  20083c:	e92d0002 	stmdb	sp!, {r1}
  200840:	e59b3000 	ldr	r3, [fp]
  200844:	e5933004 	ldr	r3, [r3, #4]
  200848:	e2033001 	and	r3, r3, #1	; 0x1
  20084c:	e20330ff 	and	r3, r3, #255	; 0xff
  200850:	e3530000 	cmp	r3, #0	; 0x0
  200854:	0a00000b 	beq	200888 <system_int+0x64>
  200858:	ebfbfe98 	bl	1002c0 <vFlibTimer_Tick>
  20085c:	e59f3040 	ldr	r3, [pc, #64]	; 2008a4 <.data+0x8a4>
  200860:	e5933000 	ldr	r3, [r3]
  200864:	e2832001 	add	r2, r3, #1	; 0x1
  200868:	e59f3034 	ldr	r3, [pc, #52]	; 2008a4 <.data+0x8a4>
  20086c:	e5832000 	str	r2, [r3]
  200870:	e3a03000 	mov	r3, #0	; 0x0
  200874:	e2433eed 	sub	r3, r3, #3792	; 0xed0
  200878:	e59b2000 	ldr	r2, [fp]
  20087c:	e5922008 	ldr	r2, [r2, #8]
  200880:	e5832000 	str	r2, [r3]
  200884:	ea000003 	b	200898 <system_int+0x74>
  200888:	e3a03000 	mov	r3, #0	; 0x0
  20088c:	e2433eed 	sub	r3, r3, #3792	; 0xed0
  200890:	e3a02000 	mov	r2, #0	; 0x0
  200894:	e5832000 	str	r2, [r3]
  200898:	e8bd0002 	ldmia	sp!, {r1}
  20089c:	e161f001 	msr	SPSR_c, r1
  2008a0:	e8fd9fff 	ldmia	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, pc}^
  2008a4:	00200a0c 	eoreq	r0, r0, ip, lsl #20

002008a8 <irq0_int>:
  2008a8:	e92d5fff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
  2008ac:	e14fe000 	mrs	lr, SPSR
  2008b0:	e92d4000 	stmdb	sp!, {lr}
  2008b4:	e321f01f 	msr	CPSR_c, #31	; 0x1f
  2008b8:	e92d4000 	stmdb	sp!, {lr}
  2008bc:	e59f3070 	ldr	r3, [pc, #112]	; 200934 <.data+0x934>
  2008c0:	e5933000 	ldr	r3, [r3]
  2008c4:	e593303c 	ldr	r3, [r3, #60]
  2008c8:	e2033601 	and	r3, r3, #1048576	; 0x100000
  2008cc:	e3530000 	cmp	r3, #0	; 0x0
  2008d0:	1a00000d 	bne	20090c <irq0_int+0x64>
  2008d4:	e59f3058 	ldr	r3, [pc, #88]	; 200934 <.data+0x934>
  2008d8:	e5932000 	ldr	r2, [r3]
  2008dc:	e3a03701 	mov	r3, #262144	; 0x40000
  2008e0:	e5823034 	str	r3, [r2, #52]
  2008e4:	e59f3048 	ldr	r3, [pc, #72]	; 200934 <.data+0x934>
  2008e8:	e5933000 	ldr	r3, [r3]
  2008ec:	e593303c 	ldr	r3, [r3, #60]
  2008f0:	e2033601 	and	r3, r3, #1048576	; 0x100000
  2008f4:	e3530000 	cmp	r3, #0	; 0x0
  2008f8:	0afffff9 	beq	2008e4 <irq0_int+0x3c>
  2008fc:	e59f3030 	ldr	r3, [pc, #48]	; 200934 <.data+0x934>
  200900:	e5932000 	ldr	r2, [r3]
  200904:	e3a03701 	mov	r3, #262144	; 0x40000
  200908:	e5823030 	str	r3, [r2, #48]
  20090c:	e8bd4000 	ldmia	sp!, {lr}
  200910:	e321f092 	msr	CPSR_c, #146	; 0x92
  200914:	e8bd4000 	ldmia	sp!, {lr}
  200918:	e16ff00e 	msr	SPSR_fsxc, lr
  20091c:	e3a03000 	mov	r3, #0	; 0x0
  200920:	e2433eed 	sub	r3, r3, #3792	; 0xed0
  200924:	e3a02000 	mov	r2, #0	; 0x0
  200928:	e5832000 	str	r2, [r3]
  20092c:	e8bd5fff 	ldmia	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
  200930:	e25ef004 	subs	pc, lr, #4	; 0x4
  200934:	00200000 	eoreq	r0, r0, r0
